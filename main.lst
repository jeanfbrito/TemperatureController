CCS PCH C Compiler, Version 4.057, 8241               12-mai-13 16:36

               Filename: main.lst

               ROM used: 3078 bytes (9%)
                         Largest free fragment is 29690
               RAM used: 19 (1%) at main() level
                         44 (3%) worst case
               Stack:    4 locations

*
0000:  GOTO   0B18
.................... #include <18f452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(clock=20000000) 
*
0374:  CLRF   FEA
0376:  MOVLW  12
0378:  MOVWF  FE9
037A:  MOVF   FEF,W
037C:  BZ    0398
037E:  MOVLW  06
0380:  MOVWF  01
0382:  CLRF   00
0384:  DECFSZ 00,F
0386:  BRA    0384
0388:  DECFSZ 01,F
038A:  BRA    0382
038C:  MOVLW  7B
038E:  MOVWF  00
0390:  DECFSZ 00,F
0392:  BRA    0390
0394:  DECFSZ FEF,F
0396:  BRA    037E
0398:  RETLW  00
039A:  MOVLW  03
039C:  SUBWF  11,F
039E:  BNC   03B2
03A0:  CLRF   FEA
03A2:  MOVLW  11
03A4:  MOVWF  FE9
03A6:  MOVF   FEF,W
03A8:  BZ    03B2
03AA:  BRA    03AE
03AC:  BRA    03AE
03AE:  DECFSZ FEF,F
03B0:  BRA    03AC
03B2:  RETLW  00
.................... #fuses HS,NOWDT,PUT 
.................... #include <lcd_generico.c> 
.................... /* 
....................  
.................... Função para utilização do display LCD para qualquer tamanho 
....................  
....................    inic_display();                        função para configurar e inicializar o display 
....................    display(char tipo,char dado);          função para enviar um comando ou um dado para o display 
....................    mostra(char dado);                     funçao para enviar um dado para o display 
....................  
....................    Configuração dos pinos do microcontrolador 
....................  
....................    RB0 = enable display 
....................    RB1 = RS 
....................    RB2 = RW 
....................    RB3 = 
....................    RB4 = DB4 
....................    RB5 = DB5 
....................    RB6 = DB6 
....................    RB7 = DB7 
....................  
....................    Primeira linha = 0x80 
....................    Segunda  linha = 0xC0 
....................  
....................  
.................... Aprimorado por Cleber Toss Hoffmann 
.................... cleber.toss.hoffmann@gmail.com 
....................  
.................... */ 
.................... // 
.................... #byte PORTB=0xF81 
.................... #byte TRISB=0xF93 
....................  
.................... //Constantes 
.................... #define set_bit0 0x01 
.................... #define set_bit1 0x02 
.................... #define set_bit2 0x04 
....................  
.................... #define clear_bit0 0xfe 
.................... #define clear_bit1 0xfd 
.................... #define clear_bit2 0xfb 
....................  
.................... void inic_display(); 
....................  
.................... #separate 
.................... void display(char tipo,char dado); 
....................  
.................... #separate 
.................... void mostra(char dado); 
....................  
.................... void inic_display() 
.................... { 
....................  TRISB =0x00; 
*
0430:  CLRF   F93
....................  delay_ms(50); 
0432:  MOVLW  32
0434:  MOVWF  12
0436:  RCALL  0374
....................  
....................  PORTB  = 0x30; 
0438:  MOVLW  30
043A:  MOVWF  F81
....................  PORTB |= set_bit0; 
043C:  BSF    F81.0
....................  delay_us(5); 
043E:  MOVLW  08
0440:  MOVWF  00
0442:  DECFSZ 00,F
0444:  BRA    0442
....................  PORTB &= clear_bit0; 
0446:  BCF    F81.0
....................  delay_ms(25); 
0448:  MOVLW  19
044A:  MOVWF  12
044C:  RCALL  0374
....................  
....................  PORTB = 0x30; 
044E:  MOVLW  30
0450:  MOVWF  F81
....................  PORTB |= set_bit0; 
0452:  BSF    F81.0
....................  delay_us(5); 
0454:  MOVLW  08
0456:  MOVWF  00
0458:  DECFSZ 00,F
045A:  BRA    0458
....................  PORTB &= clear_bit0; 
045C:  BCF    F81.0
....................  delay_ms(25); 
045E:  MOVLW  19
0460:  MOVWF  12
0462:  RCALL  0374
....................  
....................  PORTB = 0x30; 
0464:  MOVLW  30
0466:  MOVWF  F81
....................  PORTB |= set_bit0; 
0468:  BSF    F81.0
....................  delay_us(5); 
046A:  MOVLW  08
046C:  MOVWF  00
046E:  DECFSZ 00,F
0470:  BRA    046E
....................  PORTB &= clear_bit0; 
0472:  BCF    F81.0
....................  delay_ms(25); 
0474:  MOVLW  19
0476:  MOVWF  12
0478:  RCALL  0374
....................  
....................  PORTB = 0x30; 
047A:  MOVLW  30
047C:  MOVWF  F81
....................  PORTB |= set_bit0; 
047E:  BSF    F81.0
....................  delay_us(5); 
0480:  MOVLW  08
0482:  MOVWF  00
0484:  DECFSZ 00,F
0486:  BRA    0484
....................  PORTB &= clear_bit0; 
0488:  BCF    F81.0
....................  
....................  delay_us(200); 
048A:  MOVLW  C8
048C:  MOVWF  11
048E:  RCALL  039A
....................  PORTB = 0x20; 
0490:  MOVLW  20
0492:  MOVWF  F81
....................  PORTB |= set_bit0; 
0494:  BSF    F81.0
....................  delay_us(5); 
0496:  MOVLW  08
0498:  MOVWF  00
049A:  DECFSZ 00,F
049C:  BRA    049A
....................  PORTB &= clear_bit0; 
049E:  BCF    F81.0
....................  
....................  delay_us(200); 
04A0:  MOVLW  C8
04A2:  MOVWF  11
04A4:  RCALL  039A
....................  display(0,0x28); 
04A6:  CLRF   20
04A8:  MOVLW  28
04AA:  MOVWF  21
04AC:  RCALL  03B4
....................  display(0,0x08); 
04AE:  CLRF   20
04B0:  MOVLW  08
04B2:  MOVWF  21
04B4:  RCALL  03B4
....................  display(0,0x01); 
04B6:  CLRF   20
04B8:  MOVLW  01
04BA:  MOVWF  21
04BC:  RCALL  03B4
....................  delay_ms(5); 
04BE:  MOVLW  05
04C0:  MOVWF  12
04C2:  RCALL  0374
....................  display(0,0x06); 
04C4:  CLRF   20
04C6:  MOVLW  06
04C8:  MOVWF  21
04CA:  RCALL  03B4
....................  display(0,0x0c); 
04CC:  CLRF   20
04CE:  MOVLW  0C
04D0:  MOVWF  21
04D2:  RCALL  03B4
....................  
.................... } 
04D4:  GOTO   0B80 (RETURN)
....................  
....................  
.................... /* display 
....................    Envia um dado para o display. 
....................    Se tipo=0, é um comando (RS=0) 
....................    Se tipo=1, é um dado (RS=1) 
.................... */ 
.................... #separate 
.................... void display(char tipo,char dado) 
.................... { 
....................  char temp; 
....................  if(tipo == true) 
*
03B4:  DECFSZ 20,W
03B6:  BRA    03F8
....................     { 
....................      temp=(dado & 0xf0) | set_bit1; 
03B8:  MOVF   21,W
03BA:  ANDLW  F0
03BC:  IORLW  02
03BE:  MOVWF  22
....................      PORTB = temp; 
03C0:  MOVFF  22,F81
....................      PORTB |= set_bit0; 
03C4:  BSF    F81.0
....................      delay_us(5); 
03C6:  MOVLW  08
03C8:  MOVWF  00
03CA:  DECFSZ 00,F
03CC:  BRA    03CA
....................      PORTB &= clear_bit0; 
03CE:  BCF    F81.0
.................... //   delay_us(50); 
....................      temp=(dado << 4) | set_bit1; 
03D0:  SWAPF  21,W
03D2:  MOVWF  00
03D4:  MOVLW  F0
03D6:  ANDWF  00,F
03D8:  MOVF   00,W
03DA:  IORLW  02
03DC:  MOVWF  22
....................      PORTB = temp; 
03DE:  MOVFF  22,F81
....................      PORTB |= set_bit0; 
03E2:  BSF    F81.0
....................      delay_us(5); 
03E4:  MOVLW  08
03E6:  MOVWF  00
03E8:  DECFSZ 00,F
03EA:  BRA    03E8
....................      PORTB &= clear_bit0; 
03EC:  BCF    F81.0
....................      delay_us(50); 
03EE:  MOVLW  53
03F0:  MOVWF  00
03F2:  DECFSZ 00,F
03F4:  BRA    03F2
....................  
....................     } 
....................  else 
03F6:  BRA    042E
....................     { 
....................      temp=(dado & 0xf0); 
03F8:  MOVF   21,W
03FA:  ANDLW  F0
03FC:  MOVWF  22
....................      PORTB = temp; 
03FE:  MOVFF  22,F81
....................      PORTB |= set_bit0; 
0402:  BSF    F81.0
....................      delay_us(5); 
0404:  MOVLW  08
0406:  MOVWF  00
0408:  DECFSZ 00,F
040A:  BRA    0408
....................      PORTB &= clear_bit0; 
040C:  BCF    F81.0
.................... //   delay_us(50); 
....................      temp=(dado << 4); 
040E:  SWAPF  21,W
0410:  MOVWF  22
0412:  MOVLW  F0
0414:  ANDWF  22,F
....................      PORTB = temp; 
0416:  MOVFF  22,F81
....................      PORTB |= set_bit0; 
041A:  BSF    F81.0
....................      delay_us(5); 
041C:  MOVLW  08
041E:  MOVWF  00
0420:  DECFSZ 00,F
0422:  BRA    0420
....................      PORTB &= clear_bit0; 
0424:  BCF    F81.0
....................      delay_us(50); 
0426:  MOVLW  53
0428:  MOVWF  00
042A:  DECFSZ 00,F
042C:  BRA    042A
....................     } 
....................  
.................... } 
042E:  RETLW  00
....................  
.................... #separate 
.................... void mostra(char dado) 
.................... { 
....................  display(1,dado); 
*
052C:  MOVLW  01
052E:  MOVWF  20
0530:  MOVFF  1F,21
0534:  RCALL  03B4
.................... } 
0536:  RETLW  00
....................  
.................... #include "ds1307.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                               DS1307.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RTC_SDA  PIN_C4  
.................... #define RTC_SCL  PIN_C3  
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL)  
*
0052:  MOVLW  08
0054:  MOVWF  01
0056:  MOVLW  05
0058:  MOVWF  00
005A:  DECFSZ 00,F
005C:  BRA    005A
005E:  BCF    F8B.3
0060:  BCF    F94.3
0062:  MOVLW  06
0064:  MOVWF  00
0066:  DECFSZ 00,F
0068:  BRA    0066
006A:  RLCF   19,F
006C:  BCF    F8B.4
006E:  BTFSC  FD8.0
0070:  BSF    F94.4
0072:  BTFSS  FD8.0
0074:  BCF    F94.4
0076:  BSF    F94.3
0078:  BTFSS  F82.3
007A:  BRA    0078
007C:  DECFSZ 01,F
007E:  BRA    0056
0080:  MOVLW  05
0082:  MOVWF  00
0084:  DECFSZ 00,F
0086:  BRA    0084
0088:  BCF    F8B.3
008A:  BCF    F94.3
008C:  NOP   
008E:  BSF    F94.4
0090:  MOVLW  06
0092:  MOVWF  00
0094:  DECFSZ 00,F
0096:  BRA    0094
0098:  MOVLW  06
009A:  MOVWF  00
009C:  DECFSZ 00,F
009E:  BRA    009C
00A0:  BSF    F94.3
00A2:  BTFSS  F82.3
00A4:  BRA    00A2
00A6:  CLRF   01
00A8:  MOVLW  06
00AA:  MOVWF  00
00AC:  DECFSZ 00,F
00AE:  BRA    00AC
00B0:  BTFSC  F82.4
00B2:  BSF    01.0
00B4:  BCF    F8B.3
00B6:  BCF    F94.3
00B8:  BCF    F8B.4
00BA:  BCF    F94.4
00BC:  RETLW  00
00BE:  MOVLW  08
00C0:  MOVWF  15
00C2:  MOVFF  00,16
00C6:  BSF    F94.4
00C8:  MOVLW  06
00CA:  MOVWF  00
00CC:  DECFSZ 00,F
00CE:  BRA    00CC
00D0:  BSF    F94.3
00D2:  BTFSS  F82.3
00D4:  BRA    00D2
00D6:  BTFSC  F82.4
00D8:  BSF    FD8.0
00DA:  BTFSS  F82.4
00DC:  BCF    FD8.0
00DE:  RLCF   01,F
00E0:  MOVLW  05
00E2:  MOVWF  00
00E4:  DECFSZ 00,F
00E6:  BRA    00E4
00E8:  BCF    F94.3
00EA:  BCF    F8B.3
00EC:  DECFSZ 15,F
00EE:  BRA    00C6
00F0:  BSF    F94.4
00F2:  MOVLW  06
00F4:  MOVWF  00
00F6:  DECFSZ 00,F
00F8:  BRA    00F6
00FA:  BCF    F8B.4
00FC:  MOVF   16,W
00FE:  BTFSS  FD8.2
0100:  BCF    F94.4
0102:  NOP   
0104:  BSF    F94.3
0106:  BTFSS  F82.3
0108:  BRA    0106
010A:  MOVLW  05
010C:  MOVWF  00
010E:  DECFSZ 00,F
0110:  BRA    010E
0112:  BCF    F8B.3
0114:  BCF    F94.3
0116:  MOVLW  06
0118:  MOVWF  00
011A:  DECFSZ 00,F
011C:  BRA    011A
011E:  BCF    F8B.4
0120:  BCF    F94.4
0122:  RETLW  00
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);  
....................  
.................... void ds1307_init(void)  
.................... {  
....................    BYTE seconds = 0;  
*
016E:  CLRF   11
....................  
....................    i2c_start();  
0170:  BSF    F94.4
0172:  MOVLW  05
0174:  MOVWF  00
0176:  DECFSZ 00,F
0178:  BRA    0176
017A:  BSF    F94.3
017C:  MOVLW  06
017E:  MOVWF  00
0180:  DECFSZ 00,F
0182:  BRA    0180
0184:  BCF    F8B.4
0186:  BCF    F94.4
0188:  MOVLW  05
018A:  MOVWF  00
018C:  DECFSZ 00,F
018E:  BRA    018C
0190:  BCF    F8B.3
0192:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
0194:  MOVLW  D0
0196:  MOVWF  19
0198:  RCALL  0052
....................    i2c_write(0x00);      // REG 0  
019A:  CLRF   19
019C:  RCALL  0052
....................    i2c_start();  
019E:  BSF    F94.4
01A0:  MOVLW  05
01A2:  MOVWF  00
01A4:  DECFSZ 00,F
01A6:  BRA    01A4
01A8:  BSF    F94.3
01AA:  MOVLW  06
01AC:  MOVWF  00
01AE:  DECFSZ 00,F
01B0:  BRA    01AE
01B2:  BTFSS  F82.3
01B4:  BRA    01B2
01B6:  BCF    F8B.4
01B8:  BCF    F94.4
01BA:  MOVLW  05
01BC:  MOVWF  00
01BE:  DECFSZ 00,F
01C0:  BRA    01BE
01C2:  BCF    F8B.3
01C4:  BCF    F94.3
....................    i2c_write(0xD1);      // RD from RTC  
01C6:  MOVLW  D1
01C8:  MOVWF  19
01CA:  RCALL  0052
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
01CC:  CLRF   00
01CE:  RCALL  00BE
01D0:  MOVFF  01,12
01D4:  MOVFF  01,16
01D8:  RCALL  0124
01DA:  MOVFF  01,11
....................    i2c_stop();  
01DE:  BCF    F94.4
01E0:  NOP   
01E2:  BSF    F94.3
01E4:  BTFSS  F82.3
01E6:  BRA    01E4
01E8:  MOVLW  05
01EA:  MOVWF  00
01EC:  DECFSZ 00,F
01EE:  BRA    01EC
01F0:  BRA    01F2
01F2:  NOP   
01F4:  BSF    F94.4
01F6:  MOVLW  05
01F8:  MOVWF  00
01FA:  DECFSZ 00,F
01FC:  BRA    01FA
....................    seconds &= 0x7F;  
01FE:  BCF    11.7
....................  
....................    delay_us(3);  
0200:  MOVLW  04
0202:  MOVWF  00
0204:  DECFSZ 00,F
0206:  BRA    0204
0208:  BRA    020A
....................  
....................    i2c_start();  
020A:  BSF    F94.4
020C:  MOVLW  05
020E:  MOVWF  00
0210:  DECFSZ 00,F
0212:  BRA    0210
0214:  BSF    F94.3
0216:  MOVLW  06
0218:  MOVWF  00
021A:  DECFSZ 00,F
021C:  BRA    021A
021E:  BCF    F8B.4
0220:  BCF    F94.4
0222:  MOVLW  05
0224:  MOVWF  00
0226:  DECFSZ 00,F
0228:  BRA    0226
022A:  BCF    F8B.3
022C:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
022E:  MOVLW  D0
0230:  MOVWF  19
0232:  RCALL  0052
....................    i2c_write(0x00);      // REG 0  
0234:  CLRF   19
0236:  RCALL  0052
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
0238:  MOVFF  11,18
023C:  RCALL  014A
023E:  MOVFF  01,12
0242:  MOVFF  01,19
0246:  RCALL  0052
....................    i2c_start();  
0248:  BSF    F94.4
024A:  MOVLW  05
024C:  MOVWF  00
024E:  DECFSZ 00,F
0250:  BRA    024E
0252:  BSF    F94.3
0254:  MOVLW  06
0256:  MOVWF  00
0258:  DECFSZ 00,F
025A:  BRA    0258
025C:  BTFSS  F82.3
025E:  BRA    025C
0260:  BCF    F8B.4
0262:  BCF    F94.4
0264:  MOVLW  05
0266:  MOVWF  00
0268:  DECFSZ 00,F
026A:  BRA    0268
026C:  BCF    F8B.3
026E:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
0270:  MOVLW  D0
0272:  MOVWF  19
0274:  RCALL  0052
....................    i2c_write(0x07);      // Control Register  
0276:  MOVLW  07
0278:  MOVWF  19
027A:  RCALL  0052
....................    i2c_write(0x80);     // Disable squarewave output pin  
027C:  MOVLW  80
027E:  MOVWF  19
0280:  RCALL  0052
....................    i2c_stop();  
0282:  BCF    F94.4
0284:  NOP   
0286:  BSF    F94.3
0288:  BTFSS  F82.3
028A:  BRA    0288
028C:  MOVLW  05
028E:  MOVWF  00
0290:  DECFSZ 00,F
0292:  BRA    0290
0294:  BRA    0296
0296:  NOP   
0298:  BSF    F94.4
029A:  MOVLW  05
029C:  MOVWF  00
029E:  DECFSZ 00,F
02A0:  BRA    029E
....................  
.................... }  
02A2:  GOTO   0B2E (RETURN)
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... {  
....................   sec &= 0x7F;  
02A6:  BCF    17.7
....................   hr &= 0x3F;  
02A8:  MOVLW  3F
02AA:  ANDWF  15,F
....................  
....................   i2c_start();  
02AC:  BSF    F94.4
02AE:  MOVLW  05
02B0:  MOVWF  00
02B2:  DECFSZ 00,F
02B4:  BRA    02B2
02B6:  BSF    F94.3
02B8:  MOVLW  06
02BA:  MOVWF  00
02BC:  DECFSZ 00,F
02BE:  BRA    02BC
02C0:  BCF    F8B.4
02C2:  BCF    F94.4
02C4:  MOVLW  05
02C6:  MOVWF  00
02C8:  DECFSZ 00,F
02CA:  BRA    02C8
02CC:  BCF    F8B.3
02CE:  BCF    F94.3
....................   i2c_write(0xD0);            // I2C write address  
02D0:  MOVLW  D0
02D2:  MOVWF  19
02D4:  RCALL  0052
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
02D6:  CLRF   19
02D8:  RCALL  0052
....................   i2c_write(bin2bcd(sec));      // REG 0  
02DA:  MOVFF  17,18
02DE:  RCALL  014A
02E0:  MOVFF  01,18
02E4:  MOVFF  01,19
02E8:  RCALL  0052
....................   i2c_write(bin2bcd(min));      // REG 1  
02EA:  MOVFF  16,18
02EE:  RCALL  014A
02F0:  MOVFF  01,18
02F4:  MOVFF  01,19
02F8:  RCALL  0052
....................   i2c_write(bin2bcd(hr));      // REG 2  
02FA:  MOVFF  15,18
02FE:  RCALL  014A
0300:  MOVFF  01,18
0304:  MOVFF  01,19
0308:  RCALL  0052
....................   i2c_write(bin2bcd(dow));      // REG 3  
030A:  MOVFF  14,18
030E:  RCALL  014A
0310:  MOVFF  01,18
0314:  MOVFF  01,19
0318:  RCALL  0052
....................   i2c_write(bin2bcd(day));      // REG 4  
031A:  MOVFF  11,18
031E:  RCALL  014A
0320:  MOVFF  01,18
0324:  MOVFF  01,19
0328:  RCALL  0052
....................   i2c_write(bin2bcd(mth));      // REG 5  
032A:  MOVFF  12,18
032E:  RCALL  014A
0330:  MOVFF  01,18
0334:  MOVFF  01,19
0338:  RCALL  0052
....................   i2c_write(bin2bcd(year));      // REG 6  
033A:  MOVFF  13,18
033E:  RCALL  014A
0340:  MOVFF  01,18
0344:  MOVFF  01,19
0348:  RCALL  0052
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
034A:  MOVLW  80
034C:  MOVWF  19
034E:  RCALL  0052
....................   i2c_stop();  
0350:  BCF    F94.4
0352:  NOP   
0354:  BSF    F94.3
0356:  BTFSS  F82.3
0358:  BRA    0356
035A:  MOVLW  05
035C:  MOVWF  00
035E:  DECFSZ 00,F
0360:  BRA    035E
0362:  BRA    0364
0364:  NOP   
0366:  BSF    F94.4
0368:  MOVLW  05
036A:  MOVWF  00
036C:  DECFSZ 00,F
036E:  BRA    036C
.................... }  
0370:  GOTO   0B4E (RETURN)
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow)  
.................... {  
....................   i2c_start();  
....................   i2c_write(0xD0);  
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
....................   i2c_start();  
....................   i2c_write(0xD1);  
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
....................   year = bcd2bin(i2c_read(0));            // REG 6  
....................   i2c_stop();  
.................... }  
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   i2c_start();  
*
09F8:  BSF    F94.4
09FA:  MOVLW  05
09FC:  MOVWF  00
09FE:  DECFSZ 00,F
0A00:  BRA    09FE
0A02:  BSF    F94.3
0A04:  MOVLW  06
0A06:  MOVWF  00
0A08:  DECFSZ 00,F
0A0A:  BRA    0A08
0A0C:  BCF    F8B.4
0A0E:  BCF    F94.4
0A10:  MOVLW  05
0A12:  MOVWF  00
0A14:  DECFSZ 00,F
0A16:  BRA    0A14
0A18:  BCF    F8B.3
0A1A:  BCF    F94.3
....................   i2c_write(0xD0);  
0A1C:  MOVLW  D0
0A1E:  MOVWF  19
0A20:  CALL   0052
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
0A24:  CLRF   19
0A26:  CALL   0052
....................   i2c_start();  
0A2A:  BSF    F94.4
0A2C:  MOVLW  05
0A2E:  MOVWF  00
0A30:  DECFSZ 00,F
0A32:  BRA    0A30
0A34:  BSF    F94.3
0A36:  MOVLW  06
0A38:  MOVWF  00
0A3A:  DECFSZ 00,F
0A3C:  BRA    0A3A
0A3E:  BTFSS  F82.3
0A40:  BRA    0A3E
0A42:  BCF    F8B.4
0A44:  BCF    F94.4
0A46:  MOVLW  05
0A48:  MOVWF  00
0A4A:  DECFSZ 00,F
0A4C:  BRA    0A4A
0A4E:  BCF    F8B.3
0A50:  BCF    F94.3
....................   i2c_write(0xD1);  
0A52:  MOVLW  D1
0A54:  MOVWF  19
0A56:  CALL   0052
....................   sec = bcd2bin(i2c_read() & 0x7f);  
0A5A:  MOVLW  01
0A5C:  MOVWF  00
0A5E:  CALL   00BE
0A62:  MOVF   01,W
0A64:  ANDLW  7F
0A66:  MOVWF  12
0A68:  MOVWF  16
0A6A:  CALL   0124
0A6E:  MOVFF  01,05
....................   min = bcd2bin(i2c_read() & 0x7f);  
0A72:  MOVLW  01
0A74:  MOVWF  00
0A76:  CALL   00BE
0A7A:  MOVF   01,W
0A7C:  ANDLW  7F
0A7E:  MOVWF  12
0A80:  MOVWF  16
0A82:  CALL   0124
0A86:  MOVFF  01,06
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
0A8A:  CLRF   00
0A8C:  CALL   00BE
0A90:  MOVF   01,W
0A92:  ANDLW  3F
0A94:  MOVWF  12
0A96:  MOVWF  16
0A98:  CALL   0124
0A9C:  MOVFF  01,07
....................   i2c_stop();  
0AA0:  BCF    F94.4
0AA2:  NOP   
0AA4:  BSF    F94.3
0AA6:  BTFSS  F82.3
0AA8:  BRA    0AA6
0AAA:  MOVLW  05
0AAC:  MOVWF  00
0AAE:  DECFSZ 00,F
0AB0:  BRA    0AAE
0AB2:  BRA    0AB4
0AB4:  NOP   
0AB6:  BSF    F94.4
0AB8:  MOVLW  05
0ABA:  MOVWF  00
0ABC:  DECFSZ 00,F
0ABE:  BRA    0ABC
....................  
.................... }  
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................   BYTE temp;  
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
014A:  MOVFF  18,19
....................   retval = 0;  
014E:  CLRF   1A
....................  
....................   while(1)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
0150:  MOVF   19,W
0152:  SUBLW  09
0154:  BC    0160
....................     {  
....................       temp -= 10;  
0156:  MOVLW  0A
0158:  SUBWF  19,F
....................       retval += 0x10;  
015A:  MOVLW  10
015C:  ADDWF  1A,F
....................     }  
....................     else // Get the ones digit by adding the remainder.  
015E:  BRA    0166
....................     {  
....................       retval += temp;  
0160:  MOVF   19,W
0162:  ADDWF  1A,F
....................       break;  
0164:  BRA    0168
....................     }  
....................   }  
0166:  BRA    0150
....................  
....................   return(retval);  
0168:  MOVFF  1A,01
.................... }  
016C:  RETLW  00
....................  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp;  
....................  
....................   temp = bcd_value;  
*
0124:  MOVFF  16,17
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
0128:  BCF    FD8.0
012A:  RRCF   17,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
012C:  MOVLW  78
012E:  ANDWF  17,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f));  
0130:  RRCF   17,W
0132:  MOVWF  00
0134:  RRCF   00,F
0136:  MOVLW  3F
0138:  ANDWF  00,F
013A:  MOVF   00,W
013C:  ADDWF  17,W
013E:  MOVWF  18
0140:  MOVF   16,W
0142:  ANDLW  0F
0144:  ADDWF  18,W
0146:  MOVWF  01
.................... }  
0148:  RETLW  00
....................  
.................... //------------------------------------------------------------------------ 
.................... // Read one byte at the specified address. 
.................... // This function is used to access the control byte 
.................... // or the NVRAM bytes. 
....................  
.................... char ds1307_read_byte(char addr) 
.................... { 
.................... char retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
0866:  BCF    FF2.6
0868:  BCF    FF2.7
086A:  BTFSC  FF2.7
086C:  BRA    0868
.................... i2c_start(); 
086E:  BSF    F94.4
0870:  MOVLW  05
0872:  MOVWF  00
0874:  DECFSZ 00,F
0876:  BRA    0874
0878:  BSF    F94.3
087A:  MOVLW  06
087C:  MOVWF  00
087E:  DECFSZ 00,F
0880:  BRA    087E
0882:  BCF    F8B.4
0884:  BCF    F94.4
0886:  MOVLW  05
0888:  MOVWF  00
088A:  DECFSZ 00,F
088C:  BRA    088A
088E:  BCF    F8B.3
0890:  BCF    F94.3
.................... i2c_write(0xD0); 
0892:  MOVLW  D0
0894:  MOVWF  19
0896:  CALL   0052
.................... i2c_write(addr); 
089A:  MOVFF  11,19
089E:  CALL   0052
....................  
.................... i2c_start(); 
08A2:  BSF    F94.4
08A4:  MOVLW  05
08A6:  MOVWF  00
08A8:  DECFSZ 00,F
08AA:  BRA    08A8
08AC:  BSF    F94.3
08AE:  MOVLW  06
08B0:  MOVWF  00
08B2:  DECFSZ 00,F
08B4:  BRA    08B2
08B6:  BTFSS  F82.3
08B8:  BRA    08B6
08BA:  BCF    F8B.4
08BC:  BCF    F94.4
08BE:  MOVLW  05
08C0:  MOVWF  00
08C2:  DECFSZ 00,F
08C4:  BRA    08C2
08C6:  BCF    F8B.3
08C8:  BCF    F94.3
.................... i2c_write(0xD1); 
08CA:  MOVLW  D1
08CC:  MOVWF  19
08CE:  CALL   0052
.................... retval = i2c_read(0);   // Don't ACK the last byte read 
08D2:  CLRF   00
08D4:  CALL   00BE
08D8:  MOVFF  01,12
.................... i2c_stop(); 
08DC:  BCF    F94.4
08DE:  NOP   
08E0:  BSF    F94.3
08E2:  BTFSS  F82.3
08E4:  BRA    08E2
08E6:  MOVLW  05
08E8:  MOVWF  00
08EA:  DECFSZ 00,F
08EC:  BRA    08EA
08EE:  BRA    08F0
08F0:  NOP   
08F2:  BSF    F94.4
08F4:  MOVLW  05
08F6:  MOVWF  00
08F8:  DECFSZ 00,F
08FA:  BRA    08F8
.................... enable_interrupts(GLOBAL); 
08FC:  MOVLW  C0
08FE:  IORWF  FF2,F
....................  
.................... return(retval); 
0900:  MOVFF  12,01
.................... } 
0904:  GOTO   0AC4 (RETURN)
....................  
....................  
....................   
....................   BYTE sec;  
....................   BYTE min;  
....................   BYTE hrs;  
....................   BYTE day;  
....................   BYTE month;  
....................   BYTE yr;  
....................   BYTE dow;  
....................   int screen = 0; //0-Tela principal, 1-Config. Temperatura, 2-Config. Horario 
....................    
.................... update_clock();  
.................... float read_temperature(); 
....................   
.................... main() 
.................... {  
*
0B18:  CLRF   FF8
0B1A:  BCF    FD0.7
0B1C:  CLRF   FEA
0B1E:  CLRF   FE9
0B20:  BSF    FC1.0
0B22:  BSF    FC1.1
0B24:  BSF    FC1.2
0B26:  BCF    FC1.3
0B28:  CLRF   0C
....................     
....................    float temperatura; 
....................  
....................  
....................    
....................   ds1307_init();  
0B2A:  GOTO   016E
....................    
....................   // Set date for -> 15 June 2005 Tuesday  
....................   // Set time for -> 15:20:55  
....................   ds1307_set_date_time(18,11,12,2,22,05,55);  
0B2E:  MOVLW  12
0B30:  MOVWF  11
0B32:  MOVLW  0B
0B34:  MOVWF  12
0B36:  MOVLW  0C
0B38:  MOVWF  13
0B3A:  MOVLW  02
0B3C:  MOVWF  14
0B3E:  MOVLW  16
0B40:  MOVWF  15
0B42:  MOVLW  05
0B44:  MOVWF  16
0B46:  MOVLW  37
0B48:  MOVWF  17
0B4A:  GOTO   02A6
....................  
....................  
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0B4E:  BCF    FC1.6
0B50:  BSF    FC2.6
0B52:  BSF    FC2.7
0B54:  BSF    FC1.7
0B56:  BSF    FC2.0
....................    //enables the a/d module  
....................    set_adc_channel(0); 
0B58:  MOVLW  00
0B5A:  MOVWF  01
0B5C:  MOVF   FC2,W
0B5E:  ANDLW  C7
0B60:  IORWF  01,W
0B62:  MOVWF  FC2
....................    //the next read_adc call will read channel 0 
....................    delay_us(10); 
0B64:  MOVLW  10
0B66:  MOVWF  00
0B68:  DECFSZ 00,F
0B6A:  BRA    0B68
0B6C:  NOP   
....................    //a small delay is required after setting the channel 
....................  
....................    //aguarda 500ms 
....................    delay_ms(500); 
0B6E:  MOVLW  02
0B70:  MOVWF  11
0B72:  MOVLW  FA
0B74:  MOVWF  12
0B76:  CALL   0374
0B7A:  DECFSZ 11,F
0B7C:  BRA    0B72
....................     
....................    //inicializa o display LCD 
....................    inic_display(); 
0B7E:  BRA    0430
....................  
....................  
....................    while (true) 
....................    { 
....................       temperatura = read_temperature(); 
0B80:  BRA    0510
0B82:  MOVFF  03,10
0B86:  MOVFF  02,0F
0B8A:  MOVFF  01,0E
0B8E:  MOVFF  00,0D
....................  
....................       //envia o cursor do LCD para a posicao 0,0 
....................       display(0,0x80); 
0B92:  CLRF   20
0B94:  MOVLW  80
0B96:  MOVWF  21
0B98:  RCALL  03B4
....................  
....................       //imprime na tela a temperatura 
....................       printf(mostra,"Temperatura: %.1lfC   ",temperatura); 
0B9A:  CLRF   11
0B9C:  MOVF   11,W
0B9E:  CALL   0004
0BA2:  INCF   11,F
0BA4:  MOVWF  00
0BA6:  MOVWF  1F
0BA8:  RCALL  052C
0BAA:  MOVLW  0D
0BAC:  SUBWF  11,W
0BAE:  BNZ   0B9C
0BB0:  MOVLW  89
0BB2:  MOVWF  FE9
0BB4:  MOVFF  10,15
0BB8:  MOVFF  0F,14
0BBC:  MOVFF  0E,13
0BC0:  MOVFF  0D,12
0BC4:  MOVLW  01
0BC6:  MOVWF  16
0BC8:  BRA    06E6
0BCA:  MOVLW  12
0BCC:  MOVWF  12
0BCE:  MOVF   12,W
0BD0:  CALL   0004
0BD4:  INCF   12,F
0BD6:  MOVWF  00
0BD8:  MOVWF  1F
0BDA:  RCALL  052C
0BDC:  MOVLW  16
0BDE:  SUBWF  12,W
0BE0:  BNZ   0BCE
....................        
....................       //envia o cursor do LCD para a posicao 1,0 
....................       display(0,0xC0); 
0BE2:  CLRF   20
0BE4:  MOVLW  C0
0BE6:  MOVWF  21
0BE8:  CALL   03B4
....................  
....................       //imprime na tela a temperatura 
....................       update_clock(); 
0BEC:  BRA    09F8
....................  
....................       //alterna o estado do pino D4 
....................       output_toggle(PIN_a4); 
0BEE:  BCF    F92.4
0BF0:  BTG    F89.4
....................  
....................       //aguarda 500ms 
....................       delay_ms (500); 
0BF2:  MOVLW  02
0BF4:  MOVWF  11
0BF6:  MOVLW  FA
0BF8:  MOVWF  12
0BFA:  CALL   0374
0BFE:  DECFSZ 11,F
0C00:  BRA    0BF6
....................    } 
0C02:  BRA    0B80
.................... } 
....................  
.................... update_clock(){ 
....................     //ds1307_get_date(day,month,yr,dow);  
0C04:  SLEEP 
....................     ds1307_get_time(hrs,min,sec);  
....................        
....................     sec = ds1307_read_byte(0); 
*
0AC0:  CLRF   11
0AC2:  BRA    0866
0AC4:  MOVFF  01,05
....................     sec = bcd2bin(sec); 
0AC8:  MOVFF  05,16
0ACC:  CALL   0124
0AD0:  MOVFF  01,05
....................        
....................     //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................     printf(mostra,"Hora: \%02d:\%02d:\%02d", hrs,min,sec);  
0AD4:  CLRF   11
0AD6:  MOVF   11,W
0AD8:  CALL   002C
0ADC:  INCF   11,F
0ADE:  MOVWF  00
0AE0:  MOVWF  1F
0AE2:  RCALL  052C
0AE4:  MOVLW  06
0AE6:  SUBWF  11,W
0AE8:  BNZ   0AD6
0AEA:  MOVFF  07,12
0AEE:  MOVLW  01
0AF0:  MOVWF  13
0AF2:  RCALL  0930
0AF4:  MOVLW  3A
0AF6:  MOVWF  1F
0AF8:  RCALL  052C
0AFA:  MOVFF  06,12
0AFE:  MOVLW  01
0B00:  MOVWF  13
0B02:  RCALL  0930
0B04:  MOVLW  3A
0B06:  MOVWF  1F
0B08:  RCALL  052C
0B0A:  MOVFF  05,12
0B0E:  MOVLW  01
0B10:  MOVWF  13
0B12:  RCALL  0930
.................... } 
0B14:  GOTO   0BEE (RETURN)
....................  
.................... float read_temperature() { 
....................    long int temp; 
....................    //starts the conversion and reads the result 
....................    temp = read_adc(); 
*
0510:  BSF    FC2.2
0512:  BTFSC  FC2.2
0514:  BRA    0512
0516:  MOVFF  FC3,11
051A:  MOVFF  FC4,12
....................  
....................    //faz o calculo para converter a tensao em graus celsius 
....................    return(temp);//((temp - 50) * 8.9)/ 100; 
051E:  MOVFF  12,14
0522:  MOVFF  11,13
0526:  BRA    04D8
.................... } 
0528:  GOTO   0B82 (RETURN)

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
