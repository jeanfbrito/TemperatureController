CCS PCH C Compiler, Version 4.057, 8241               12-mai-13 16:29

               Filename: main.lst

               ROM used: 3066 bytes (9%)
                         Largest free fragment is 29702
               RAM used: 20 (1%) at main() level
                         45 (3%) worst case
               Stack:    4 locations

*
0000:  GOTO   0AFA
.................... #include <18f452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(clock=20000000) 
*
0374:  CLRF   FEA
0376:  MOVLW  13
0378:  MOVWF  FE9
037A:  MOVF   FEF,W
037C:  BZ    0398
037E:  MOVLW  06
0380:  MOVWF  01
0382:  CLRF   00
0384:  DECFSZ 00,F
0386:  BRA    0384
0388:  DECFSZ 01,F
038A:  BRA    0382
038C:  MOVLW  7B
038E:  MOVWF  00
0390:  DECFSZ 00,F
0392:  BRA    0390
0394:  DECFSZ FEF,F
0396:  BRA    037E
0398:  RETLW  00
039A:  MOVLW  03
039C:  SUBWF  12,F
039E:  BNC   03B2
03A0:  CLRF   FEA
03A2:  MOVLW  12
03A4:  MOVWF  FE9
03A6:  MOVF   FEF,W
03A8:  BZ    03B2
03AA:  BRA    03AE
03AC:  BRA    03AE
03AE:  DECFSZ FEF,F
03B0:  BRA    03AC
03B2:  RETLW  00
.................... #fuses HS,NOWDT,PUT 
.................... #include <lcd_generico.c> 
.................... /* 
....................  
.................... Função para utilização do display LCD para qualquer tamanho 
....................  
....................    inic_display();                        função para configurar e inicializar o display 
....................    display(char tipo,char dado);          função para enviar um comando ou um dado para o display 
....................    mostra(char dado);                     funçao para enviar um dado para o display 
....................  
....................    Configuração dos pinos do microcontrolador 
....................  
....................    RB0 = enable display 
....................    RB1 = RS 
....................    RB2 = RW 
....................    RB3 = 
....................    RB4 = DB4 
....................    RB5 = DB5 
....................    RB6 = DB6 
....................    RB7 = DB7 
....................  
....................    Primeira linha = 0x80 
....................    Segunda  linha = 0xC0 
....................  
....................  
.................... Aprimorado por Cleber Toss Hoffmann 
.................... cleber.toss.hoffmann@gmail.com 
....................  
.................... */ 
.................... // 
.................... #byte PORTB=0xF81 
.................... #byte TRISB=0xF93 
....................  
.................... //Constantes 
.................... #define set_bit0 0x01 
.................... #define set_bit1 0x02 
.................... #define set_bit2 0x04 
....................  
.................... #define clear_bit0 0xfe 
.................... #define clear_bit1 0xfd 
.................... #define clear_bit2 0xfb 
....................  
.................... void inic_display(); 
....................  
.................... #separate 
.................... void display(char tipo,char dado); 
....................  
.................... #separate 
.................... void mostra(char dado); 
....................  
.................... void inic_display() 
.................... { 
....................  TRISB =0x00; 
*
0430:  CLRF   F93
....................  delay_ms(50); 
0432:  MOVLW  32
0434:  MOVWF  13
0436:  RCALL  0374
....................  
....................  PORTB  = 0x30; 
0438:  MOVLW  30
043A:  MOVWF  F81
....................  PORTB |= set_bit0; 
043C:  BSF    F81.0
....................  delay_us(5); 
043E:  MOVLW  08
0440:  MOVWF  00
0442:  DECFSZ 00,F
0444:  BRA    0442
....................  PORTB &= clear_bit0; 
0446:  BCF    F81.0
....................  delay_ms(25); 
0448:  MOVLW  19
044A:  MOVWF  13
044C:  RCALL  0374
....................  
....................  PORTB = 0x30; 
044E:  MOVLW  30
0450:  MOVWF  F81
....................  PORTB |= set_bit0; 
0452:  BSF    F81.0
....................  delay_us(5); 
0454:  MOVLW  08
0456:  MOVWF  00
0458:  DECFSZ 00,F
045A:  BRA    0458
....................  PORTB &= clear_bit0; 
045C:  BCF    F81.0
....................  delay_ms(25); 
045E:  MOVLW  19
0460:  MOVWF  13
0462:  RCALL  0374
....................  
....................  PORTB = 0x30; 
0464:  MOVLW  30
0466:  MOVWF  F81
....................  PORTB |= set_bit0; 
0468:  BSF    F81.0
....................  delay_us(5); 
046A:  MOVLW  08
046C:  MOVWF  00
046E:  DECFSZ 00,F
0470:  BRA    046E
....................  PORTB &= clear_bit0; 
0472:  BCF    F81.0
....................  delay_ms(25); 
0474:  MOVLW  19
0476:  MOVWF  13
0478:  RCALL  0374
....................  
....................  PORTB = 0x30; 
047A:  MOVLW  30
047C:  MOVWF  F81
....................  PORTB |= set_bit0; 
047E:  BSF    F81.0
....................  delay_us(5); 
0480:  MOVLW  08
0482:  MOVWF  00
0484:  DECFSZ 00,F
0486:  BRA    0484
....................  PORTB &= clear_bit0; 
0488:  BCF    F81.0
....................  
....................  delay_us(200); 
048A:  MOVLW  C8
048C:  MOVWF  12
048E:  RCALL  039A
....................  PORTB = 0x20; 
0490:  MOVLW  20
0492:  MOVWF  F81
....................  PORTB |= set_bit0; 
0494:  BSF    F81.0
....................  delay_us(5); 
0496:  MOVLW  08
0498:  MOVWF  00
049A:  DECFSZ 00,F
049C:  BRA    049A
....................  PORTB &= clear_bit0; 
049E:  BCF    F81.0
....................  
....................  delay_us(200); 
04A0:  MOVLW  C8
04A2:  MOVWF  12
04A4:  RCALL  039A
....................  display(0,0x28); 
04A6:  CLRF   21
04A8:  MOVLW  28
04AA:  MOVWF  22
04AC:  RCALL  03B4
....................  display(0,0x08); 
04AE:  CLRF   21
04B0:  MOVLW  08
04B2:  MOVWF  22
04B4:  RCALL  03B4
....................  display(0,0x01); 
04B6:  CLRF   21
04B8:  MOVLW  01
04BA:  MOVWF  22
04BC:  RCALL  03B4
....................  delay_ms(5); 
04BE:  MOVLW  05
04C0:  MOVWF  13
04C2:  RCALL  0374
....................  display(0,0x06); 
04C4:  CLRF   21
04C6:  MOVLW  06
04C8:  MOVWF  22
04CA:  RCALL  03B4
....................  display(0,0x0c); 
04CC:  CLRF   21
04CE:  MOVLW  0C
04D0:  MOVWF  22
04D2:  RCALL  03B4
....................  
.................... } 
04D4:  GOTO   0B5E (RETURN)
....................  
....................  
.................... /* display 
....................    Envia um dado para o display. 
....................    Se tipo=0, é um comando (RS=0) 
....................    Se tipo=1, é um dado (RS=1) 
.................... */ 
.................... #separate 
.................... void display(char tipo,char dado) 
.................... { 
....................  char temp; 
....................  if(tipo == true) 
*
03B4:  DECFSZ 21,W
03B6:  BRA    03F8
....................     { 
....................      temp=(dado & 0xf0) | set_bit1; 
03B8:  MOVF   22,W
03BA:  ANDLW  F0
03BC:  IORLW  02
03BE:  MOVWF  23
....................      PORTB = temp; 
03C0:  MOVFF  23,F81
....................      PORTB |= set_bit0; 
03C4:  BSF    F81.0
....................      delay_us(5); 
03C6:  MOVLW  08
03C8:  MOVWF  00
03CA:  DECFSZ 00,F
03CC:  BRA    03CA
....................      PORTB &= clear_bit0; 
03CE:  BCF    F81.0
.................... //   delay_us(50); 
....................      temp=(dado << 4) | set_bit1; 
03D0:  SWAPF  22,W
03D2:  MOVWF  00
03D4:  MOVLW  F0
03D6:  ANDWF  00,F
03D8:  MOVF   00,W
03DA:  IORLW  02
03DC:  MOVWF  23
....................      PORTB = temp; 
03DE:  MOVFF  23,F81
....................      PORTB |= set_bit0; 
03E2:  BSF    F81.0
....................      delay_us(5); 
03E4:  MOVLW  08
03E6:  MOVWF  00
03E8:  DECFSZ 00,F
03EA:  BRA    03E8
....................      PORTB &= clear_bit0; 
03EC:  BCF    F81.0
....................      delay_us(50); 
03EE:  MOVLW  53
03F0:  MOVWF  00
03F2:  DECFSZ 00,F
03F4:  BRA    03F2
....................  
....................     } 
....................  else 
03F6:  BRA    042E
....................     { 
....................      temp=(dado & 0xf0); 
03F8:  MOVF   22,W
03FA:  ANDLW  F0
03FC:  MOVWF  23
....................      PORTB = temp; 
03FE:  MOVFF  23,F81
....................      PORTB |= set_bit0; 
0402:  BSF    F81.0
....................      delay_us(5); 
0404:  MOVLW  08
0406:  MOVWF  00
0408:  DECFSZ 00,F
040A:  BRA    0408
....................      PORTB &= clear_bit0; 
040C:  BCF    F81.0
.................... //   delay_us(50); 
....................      temp=(dado << 4); 
040E:  SWAPF  22,W
0410:  MOVWF  23
0412:  MOVLW  F0
0414:  ANDWF  23,F
....................      PORTB = temp; 
0416:  MOVFF  23,F81
....................      PORTB |= set_bit0; 
041A:  BSF    F81.0
....................      delay_us(5); 
041C:  MOVLW  08
041E:  MOVWF  00
0420:  DECFSZ 00,F
0422:  BRA    0420
....................      PORTB &= clear_bit0; 
0424:  BCF    F81.0
....................      delay_us(50); 
0426:  MOVLW  53
0428:  MOVWF  00
042A:  DECFSZ 00,F
042C:  BRA    042A
....................     } 
....................  
.................... } 
042E:  RETLW  00
....................  
.................... #separate 
.................... void mostra(char dado) 
.................... { 
....................  display(1,dado); 
*
0510:  MOVLW  01
0512:  MOVWF  21
0514:  MOVFF  20,22
0518:  RCALL  03B4
.................... } 
051A:  RETLW  00
....................  
.................... #include "ds1307.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                               DS1307.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RTC_SDA  PIN_C4  
.................... #define RTC_SCL  PIN_C3  
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL)  
*
0052:  MOVLW  08
0054:  MOVWF  01
0056:  MOVLW  05
0058:  MOVWF  00
005A:  DECFSZ 00,F
005C:  BRA    005A
005E:  BCF    F8B.3
0060:  BCF    F94.3
0062:  MOVLW  06
0064:  MOVWF  00
0066:  DECFSZ 00,F
0068:  BRA    0066
006A:  RLCF   1A,F
006C:  BCF    F8B.4
006E:  BTFSC  FD8.0
0070:  BSF    F94.4
0072:  BTFSS  FD8.0
0074:  BCF    F94.4
0076:  BSF    F94.3
0078:  BTFSS  F82.3
007A:  BRA    0078
007C:  DECFSZ 01,F
007E:  BRA    0056
0080:  MOVLW  05
0082:  MOVWF  00
0084:  DECFSZ 00,F
0086:  BRA    0084
0088:  BCF    F8B.3
008A:  BCF    F94.3
008C:  NOP   
008E:  BSF    F94.4
0090:  MOVLW  06
0092:  MOVWF  00
0094:  DECFSZ 00,F
0096:  BRA    0094
0098:  MOVLW  06
009A:  MOVWF  00
009C:  DECFSZ 00,F
009E:  BRA    009C
00A0:  BSF    F94.3
00A2:  BTFSS  F82.3
00A4:  BRA    00A2
00A6:  CLRF   01
00A8:  MOVLW  06
00AA:  MOVWF  00
00AC:  DECFSZ 00,F
00AE:  BRA    00AC
00B0:  BTFSC  F82.4
00B2:  BSF    01.0
00B4:  BCF    F8B.3
00B6:  BCF    F94.3
00B8:  BCF    F8B.4
00BA:  BCF    F94.4
00BC:  RETLW  00
00BE:  MOVLW  08
00C0:  MOVWF  16
00C2:  MOVFF  00,17
00C6:  BSF    F94.4
00C8:  MOVLW  06
00CA:  MOVWF  00
00CC:  DECFSZ 00,F
00CE:  BRA    00CC
00D0:  BSF    F94.3
00D2:  BTFSS  F82.3
00D4:  BRA    00D2
00D6:  BTFSC  F82.4
00D8:  BSF    FD8.0
00DA:  BTFSS  F82.4
00DC:  BCF    FD8.0
00DE:  RLCF   01,F
00E0:  MOVLW  05
00E2:  MOVWF  00
00E4:  DECFSZ 00,F
00E6:  BRA    00E4
00E8:  BCF    F94.3
00EA:  BCF    F8B.3
00EC:  DECFSZ 16,F
00EE:  BRA    00C6
00F0:  BSF    F94.4
00F2:  MOVLW  06
00F4:  MOVWF  00
00F6:  DECFSZ 00,F
00F8:  BRA    00F6
00FA:  BCF    F8B.4
00FC:  MOVF   17,W
00FE:  BTFSS  FD8.2
0100:  BCF    F94.4
0102:  NOP   
0104:  BSF    F94.3
0106:  BTFSS  F82.3
0108:  BRA    0106
010A:  MOVLW  05
010C:  MOVWF  00
010E:  DECFSZ 00,F
0110:  BRA    010E
0112:  BCF    F8B.3
0114:  BCF    F94.3
0116:  MOVLW  06
0118:  MOVWF  00
011A:  DECFSZ 00,F
011C:  BRA    011A
011E:  BCF    F8B.4
0120:  BCF    F94.4
0122:  RETLW  00
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);  
....................  
.................... void ds1307_init(void)  
.................... {  
....................    BYTE seconds = 0;  
*
016E:  CLRF   12
....................  
....................    i2c_start();  
0170:  BSF    F94.4
0172:  MOVLW  05
0174:  MOVWF  00
0176:  DECFSZ 00,F
0178:  BRA    0176
017A:  BSF    F94.3
017C:  MOVLW  06
017E:  MOVWF  00
0180:  DECFSZ 00,F
0182:  BRA    0180
0184:  BCF    F8B.4
0186:  BCF    F94.4
0188:  MOVLW  05
018A:  MOVWF  00
018C:  DECFSZ 00,F
018E:  BRA    018C
0190:  BCF    F8B.3
0192:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
0194:  MOVLW  D0
0196:  MOVWF  1A
0198:  RCALL  0052
....................    i2c_write(0x00);      // REG 0  
019A:  CLRF   1A
019C:  RCALL  0052
....................    i2c_start();  
019E:  BSF    F94.4
01A0:  MOVLW  05
01A2:  MOVWF  00
01A4:  DECFSZ 00,F
01A6:  BRA    01A4
01A8:  BSF    F94.3
01AA:  MOVLW  06
01AC:  MOVWF  00
01AE:  DECFSZ 00,F
01B0:  BRA    01AE
01B2:  BTFSS  F82.3
01B4:  BRA    01B2
01B6:  BCF    F8B.4
01B8:  BCF    F94.4
01BA:  MOVLW  05
01BC:  MOVWF  00
01BE:  DECFSZ 00,F
01C0:  BRA    01BE
01C2:  BCF    F8B.3
01C4:  BCF    F94.3
....................    i2c_write(0xD1);      // RD from RTC  
01C6:  MOVLW  D1
01C8:  MOVWF  1A
01CA:  RCALL  0052
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
01CC:  CLRF   00
01CE:  RCALL  00BE
01D0:  MOVFF  01,13
01D4:  MOVFF  01,17
01D8:  RCALL  0124
01DA:  MOVFF  01,12
....................    i2c_stop();  
01DE:  BCF    F94.4
01E0:  NOP   
01E2:  BSF    F94.3
01E4:  BTFSS  F82.3
01E6:  BRA    01E4
01E8:  MOVLW  05
01EA:  MOVWF  00
01EC:  DECFSZ 00,F
01EE:  BRA    01EC
01F0:  BRA    01F2
01F2:  NOP   
01F4:  BSF    F94.4
01F6:  MOVLW  05
01F8:  MOVWF  00
01FA:  DECFSZ 00,F
01FC:  BRA    01FA
....................    seconds &= 0x7F;  
01FE:  BCF    12.7
....................  
....................    delay_us(3);  
0200:  MOVLW  04
0202:  MOVWF  00
0204:  DECFSZ 00,F
0206:  BRA    0204
0208:  BRA    020A
....................  
....................    i2c_start();  
020A:  BSF    F94.4
020C:  MOVLW  05
020E:  MOVWF  00
0210:  DECFSZ 00,F
0212:  BRA    0210
0214:  BSF    F94.3
0216:  MOVLW  06
0218:  MOVWF  00
021A:  DECFSZ 00,F
021C:  BRA    021A
021E:  BCF    F8B.4
0220:  BCF    F94.4
0222:  MOVLW  05
0224:  MOVWF  00
0226:  DECFSZ 00,F
0228:  BRA    0226
022A:  BCF    F8B.3
022C:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
022E:  MOVLW  D0
0230:  MOVWF  1A
0232:  RCALL  0052
....................    i2c_write(0x00);      // REG 0  
0234:  CLRF   1A
0236:  RCALL  0052
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
0238:  MOVFF  12,19
023C:  RCALL  014A
023E:  MOVFF  01,13
0242:  MOVFF  01,1A
0246:  RCALL  0052
....................    i2c_start();  
0248:  BSF    F94.4
024A:  MOVLW  05
024C:  MOVWF  00
024E:  DECFSZ 00,F
0250:  BRA    024E
0252:  BSF    F94.3
0254:  MOVLW  06
0256:  MOVWF  00
0258:  DECFSZ 00,F
025A:  BRA    0258
025C:  BTFSS  F82.3
025E:  BRA    025C
0260:  BCF    F8B.4
0262:  BCF    F94.4
0264:  MOVLW  05
0266:  MOVWF  00
0268:  DECFSZ 00,F
026A:  BRA    0268
026C:  BCF    F8B.3
026E:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
0270:  MOVLW  D0
0272:  MOVWF  1A
0274:  RCALL  0052
....................    i2c_write(0x07);      // Control Register  
0276:  MOVLW  07
0278:  MOVWF  1A
027A:  RCALL  0052
....................    i2c_write(0x80);     // Disable squarewave output pin  
027C:  MOVLW  80
027E:  MOVWF  1A
0280:  RCALL  0052
....................    i2c_stop();  
0282:  BCF    F94.4
0284:  NOP   
0286:  BSF    F94.3
0288:  BTFSS  F82.3
028A:  BRA    0288
028C:  MOVLW  05
028E:  MOVWF  00
0290:  DECFSZ 00,F
0292:  BRA    0290
0294:  BRA    0296
0296:  NOP   
0298:  BSF    F94.4
029A:  MOVLW  05
029C:  MOVWF  00
029E:  DECFSZ 00,F
02A0:  BRA    029E
....................  
.................... }  
02A2:  GOTO   0B0E (RETURN)
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... {  
....................   sec &= 0x7F;  
02A6:  BCF    18.7
....................   hr &= 0x3F;  
02A8:  MOVLW  3F
02AA:  ANDWF  16,F
....................  
....................   i2c_start();  
02AC:  BSF    F94.4
02AE:  MOVLW  05
02B0:  MOVWF  00
02B2:  DECFSZ 00,F
02B4:  BRA    02B2
02B6:  BSF    F94.3
02B8:  MOVLW  06
02BA:  MOVWF  00
02BC:  DECFSZ 00,F
02BE:  BRA    02BC
02C0:  BCF    F8B.4
02C2:  BCF    F94.4
02C4:  MOVLW  05
02C6:  MOVWF  00
02C8:  DECFSZ 00,F
02CA:  BRA    02C8
02CC:  BCF    F8B.3
02CE:  BCF    F94.3
....................   i2c_write(0xD0);            // I2C write address  
02D0:  MOVLW  D0
02D2:  MOVWF  1A
02D4:  RCALL  0052
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
02D6:  CLRF   1A
02D8:  RCALL  0052
....................   i2c_write(bin2bcd(sec));      // REG 0  
02DA:  MOVFF  18,19
02DE:  RCALL  014A
02E0:  MOVFF  01,19
02E4:  MOVFF  01,1A
02E8:  RCALL  0052
....................   i2c_write(bin2bcd(min));      // REG 1  
02EA:  MOVFF  17,19
02EE:  RCALL  014A
02F0:  MOVFF  01,19
02F4:  MOVFF  01,1A
02F8:  RCALL  0052
....................   i2c_write(bin2bcd(hr));      // REG 2  
02FA:  MOVFF  16,19
02FE:  RCALL  014A
0300:  MOVFF  01,19
0304:  MOVFF  01,1A
0308:  RCALL  0052
....................   i2c_write(bin2bcd(dow));      // REG 3  
030A:  MOVFF  15,19
030E:  RCALL  014A
0310:  MOVFF  01,19
0314:  MOVFF  01,1A
0318:  RCALL  0052
....................   i2c_write(bin2bcd(day));      // REG 4  
031A:  MOVFF  12,19
031E:  RCALL  014A
0320:  MOVFF  01,19
0324:  MOVFF  01,1A
0328:  RCALL  0052
....................   i2c_write(bin2bcd(mth));      // REG 5  
032A:  MOVFF  13,19
032E:  RCALL  014A
0330:  MOVFF  01,19
0334:  MOVFF  01,1A
0338:  RCALL  0052
....................   i2c_write(bin2bcd(year));      // REG 6  
033A:  MOVFF  14,19
033E:  RCALL  014A
0340:  MOVFF  01,19
0344:  MOVFF  01,1A
0348:  RCALL  0052
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
034A:  MOVLW  80
034C:  MOVWF  1A
034E:  RCALL  0052
....................   i2c_stop();  
0350:  BCF    F94.4
0352:  NOP   
0354:  BSF    F94.3
0356:  BTFSS  F82.3
0358:  BRA    0356
035A:  MOVLW  05
035C:  MOVWF  00
035E:  DECFSZ 00,F
0360:  BRA    035E
0362:  BRA    0364
0364:  NOP   
0366:  BSF    F94.4
0368:  MOVLW  05
036A:  MOVWF  00
036C:  DECFSZ 00,F
036E:  BRA    036C
.................... }  
0370:  GOTO   0B2E (RETURN)
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow)  
.................... {  
....................   i2c_start();  
....................   i2c_write(0xD0);  
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
....................   i2c_start();  
....................   i2c_write(0xD1);  
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
....................   year = bcd2bin(i2c_read(0));            // REG 6  
....................   i2c_stop();  
.................... }  
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   i2c_start();  
*
09DA:  BSF    F94.4
09DC:  MOVLW  05
09DE:  MOVWF  00
09E0:  DECFSZ 00,F
09E2:  BRA    09E0
09E4:  BSF    F94.3
09E6:  MOVLW  06
09E8:  MOVWF  00
09EA:  DECFSZ 00,F
09EC:  BRA    09EA
09EE:  BCF    F8B.4
09F0:  BCF    F94.4
09F2:  MOVLW  05
09F4:  MOVWF  00
09F6:  DECFSZ 00,F
09F8:  BRA    09F6
09FA:  BCF    F8B.3
09FC:  BCF    F94.3
....................   i2c_write(0xD0);  
09FE:  MOVLW  D0
0A00:  MOVWF  1A
0A02:  CALL   0052
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
0A06:  CLRF   1A
0A08:  CALL   0052
....................   i2c_start();  
0A0C:  BSF    F94.4
0A0E:  MOVLW  05
0A10:  MOVWF  00
0A12:  DECFSZ 00,F
0A14:  BRA    0A12
0A16:  BSF    F94.3
0A18:  MOVLW  06
0A1A:  MOVWF  00
0A1C:  DECFSZ 00,F
0A1E:  BRA    0A1C
0A20:  BTFSS  F82.3
0A22:  BRA    0A20
0A24:  BCF    F8B.4
0A26:  BCF    F94.4
0A28:  MOVLW  05
0A2A:  MOVWF  00
0A2C:  DECFSZ 00,F
0A2E:  BRA    0A2C
0A30:  BCF    F8B.3
0A32:  BCF    F94.3
....................   i2c_write(0xD1);  
0A34:  MOVLW  D1
0A36:  MOVWF  1A
0A38:  CALL   0052
....................   sec = bcd2bin(i2c_read() & 0x7f);  
0A3C:  MOVLW  01
0A3E:  MOVWF  00
0A40:  CALL   00BE
0A44:  MOVF   01,W
0A46:  ANDLW  7F
0A48:  MOVWF  13
0A4A:  MOVWF  17
0A4C:  CALL   0124
0A50:  MOVFF  01,05
....................   min = bcd2bin(i2c_read() & 0x7f);  
0A54:  MOVLW  01
0A56:  MOVWF  00
0A58:  CALL   00BE
0A5C:  MOVF   01,W
0A5E:  ANDLW  7F
0A60:  MOVWF  13
0A62:  MOVWF  17
0A64:  CALL   0124
0A68:  MOVFF  01,06
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
0A6C:  CLRF   00
0A6E:  CALL   00BE
0A72:  MOVF   01,W
0A74:  ANDLW  3F
0A76:  MOVWF  13
0A78:  MOVWF  17
0A7A:  CALL   0124
0A7E:  MOVFF  01,07
....................   i2c_stop();  
0A82:  BCF    F94.4
0A84:  NOP   
0A86:  BSF    F94.3
0A88:  BTFSS  F82.3
0A8A:  BRA    0A88
0A8C:  MOVLW  05
0A8E:  MOVWF  00
0A90:  DECFSZ 00,F
0A92:  BRA    0A90
0A94:  BRA    0A96
0A96:  NOP   
0A98:  BSF    F94.4
0A9A:  MOVLW  05
0A9C:  MOVWF  00
0A9E:  DECFSZ 00,F
0AA0:  BRA    0A9E
....................  
.................... }  
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................   BYTE temp;  
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
014A:  MOVFF  19,1A
....................   retval = 0;  
014E:  CLRF   1B
....................  
....................   while(1)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
0150:  MOVF   1A,W
0152:  SUBLW  09
0154:  BC    0160
....................     {  
....................       temp -= 10;  
0156:  MOVLW  0A
0158:  SUBWF  1A,F
....................       retval += 0x10;  
015A:  MOVLW  10
015C:  ADDWF  1B,F
....................     }  
....................     else // Get the ones digit by adding the remainder.  
015E:  BRA    0166
....................     {  
....................       retval += temp;  
0160:  MOVF   1A,W
0162:  ADDWF  1B,F
....................       break;  
0164:  BRA    0168
....................     }  
....................   }  
0166:  BRA    0150
....................  
....................   return(retval);  
0168:  MOVFF  1B,01
.................... }  
016C:  RETLW  00
....................  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp;  
....................  
....................   temp = bcd_value;  
*
0124:  MOVFF  17,18
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
0128:  BCF    FD8.0
012A:  RRCF   18,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
012C:  MOVLW  78
012E:  ANDWF  18,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f));  
0130:  RRCF   18,W
0132:  MOVWF  00
0134:  RRCF   00,F
0136:  MOVLW  3F
0138:  ANDWF  00,F
013A:  MOVF   00,W
013C:  ADDWF  18,W
013E:  MOVWF  19
0140:  MOVF   17,W
0142:  ANDLW  0F
0144:  ADDWF  19,W
0146:  MOVWF  01
.................... }  
0148:  RETLW  00
....................  
.................... //------------------------------------------------------------------------ 
.................... // Read one byte at the specified address. 
.................... // This function is used to access the control byte 
.................... // or the NVRAM bytes. 
....................  
.................... char ds1307_read_byte(char addr) 
.................... { 
.................... char retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
084A:  BCF    FF2.6
084C:  BCF    FF2.7
084E:  BTFSC  FF2.7
0850:  BRA    084C
.................... i2c_start(); 
0852:  BSF    F94.4
0854:  MOVLW  05
0856:  MOVWF  00
0858:  DECFSZ 00,F
085A:  BRA    0858
085C:  BSF    F94.3
085E:  MOVLW  06
0860:  MOVWF  00
0862:  DECFSZ 00,F
0864:  BRA    0862
0866:  BCF    F8B.4
0868:  BCF    F94.4
086A:  MOVLW  05
086C:  MOVWF  00
086E:  DECFSZ 00,F
0870:  BRA    086E
0872:  BCF    F8B.3
0874:  BCF    F94.3
.................... i2c_write(0xD0); 
0876:  MOVLW  D0
0878:  MOVWF  1A
087A:  CALL   0052
.................... i2c_write(addr); 
087E:  MOVFF  12,1A
0882:  CALL   0052
....................  
.................... i2c_start(); 
0886:  BSF    F94.4
0888:  MOVLW  05
088A:  MOVWF  00
088C:  DECFSZ 00,F
088E:  BRA    088C
0890:  BSF    F94.3
0892:  MOVLW  06
0894:  MOVWF  00
0896:  DECFSZ 00,F
0898:  BRA    0896
089A:  BTFSS  F82.3
089C:  BRA    089A
089E:  BCF    F8B.4
08A0:  BCF    F94.4
08A2:  MOVLW  05
08A4:  MOVWF  00
08A6:  DECFSZ 00,F
08A8:  BRA    08A6
08AA:  BCF    F8B.3
08AC:  BCF    F94.3
.................... i2c_write(0xD1); 
08AE:  MOVLW  D1
08B0:  MOVWF  1A
08B2:  CALL   0052
.................... retval = i2c_read(0);   // Don't ACK the last byte read 
08B6:  CLRF   00
08B8:  RCALL  00BE
08BA:  MOVFF  01,13
.................... i2c_stop(); 
08BE:  BCF    F94.4
08C0:  NOP   
08C2:  BSF    F94.3
08C4:  BTFSS  F82.3
08C6:  BRA    08C4
08C8:  MOVLW  05
08CA:  MOVWF  00
08CC:  DECFSZ 00,F
08CE:  BRA    08CC
08D0:  BRA    08D2
08D2:  NOP   
08D4:  BSF    F94.4
08D6:  MOVLW  05
08D8:  MOVWF  00
08DA:  DECFSZ 00,F
08DC:  BRA    08DA
.................... enable_interrupts(GLOBAL); 
08DE:  MOVLW  C0
08E0:  IORWF  FF2,F
....................  
.................... return(retval); 
08E2:  MOVFF  13,01
.................... } 
08E6:  GOTO   0AA6 (RETURN)
....................  
....................  
....................   
....................   BYTE sec;  
....................   BYTE min;  
....................   BYTE hrs;  
....................   BYTE day;  
....................   BYTE month;  
....................   BYTE yr;  
....................   BYTE dow;  
....................    
.................... update_clock();  
....................   
.................... main() 
.................... {  
*
0AFA:  CLRF   FF8
0AFC:  BCF    FD0.7
0AFE:  CLRF   FEA
0B00:  CLRF   FE9
0B02:  BSF    FC1.0
0B04:  BSF    FC1.1
0B06:  BSF    FC1.2
0B08:  BCF    FC1.3
....................     
....................    long int temp; 
....................    float temperatura; 
....................  
....................  
....................    
....................   ds1307_init();  
0B0A:  GOTO   016E
....................    
....................   // Set date for -> 15 June 2005 Tuesday  
....................   // Set time for -> 15:20:55  
....................   ds1307_set_date_time(18,11,12,2,22,05,55);  
0B0E:  MOVLW  12
0B10:  MOVWF  12
0B12:  MOVLW  0B
0B14:  MOVWF  13
0B16:  MOVLW  0C
0B18:  MOVWF  14
0B1A:  MOVLW  02
0B1C:  MOVWF  15
0B1E:  MOVLW  16
0B20:  MOVWF  16
0B22:  MOVLW  05
0B24:  MOVWF  17
0B26:  MOVLW  37
0B28:  MOVWF  18
0B2A:  GOTO   02A6
....................  
....................  
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0B2E:  BCF    FC1.6
0B30:  BSF    FC2.6
0B32:  BSF    FC2.7
0B34:  BSF    FC1.7
0B36:  BSF    FC2.0
....................    //enables the a/d module  
....................    set_adc_channel(0); 
0B38:  MOVLW  00
0B3A:  MOVWF  01
0B3C:  MOVF   FC2,W
0B3E:  ANDLW  C7
0B40:  IORWF  01,W
0B42:  MOVWF  FC2
....................    //the next read_adc call will read channel 0 
....................    delay_us(10); 
0B44:  MOVLW  10
0B46:  MOVWF  00
0B48:  DECFSZ 00,F
0B4A:  BRA    0B48
0B4C:  NOP   
....................    //a small delay is required after setting the channel 
....................  
....................    //aguarda 500ms 
....................    delay_ms(500); 
0B4E:  MOVLW  02
0B50:  MOVWF  12
0B52:  MOVLW  FA
0B54:  MOVWF  13
0B56:  RCALL  0374
0B58:  DECFSZ 12,F
0B5A:  BRA    0B52
....................     
....................    //inicializa o display LCD 
....................    inic_display(); 
0B5C:  BRA    0430
....................  
....................  
....................    while (true) 
....................    { 
....................  
....................       //starts the conversion and reads the result 
....................       temp = read_adc(); 
0B5E:  BSF    FC2.2
0B60:  BTFSC  FC2.2
0B62:  BRA    0B60
0B64:  MOVFF  FC3,0C
0B68:  MOVFF  FC4,0D
....................  
....................       //faz o calculo para converter a tensao em graus celsius 
....................       temperatura = temp;//((temp - 50) * 8.9)/ 100; 
0B6C:  MOVFF  0D,13
0B70:  MOVFF  0C,12
0B74:  BRA    04D8
0B76:  MOVFF  03,11
0B7A:  MOVFF  02,10
0B7E:  MOVFF  01,0F
0B82:  MOVFF  00,0E
....................  
....................       //envia o cursor do LCD para a posicao 0,0 
....................       display(0,0x80); 
0B86:  CLRF   21
0B88:  MOVLW  80
0B8A:  MOVWF  22
0B8C:  RCALL  03B4
....................  
....................       //imprime na tela a temperatura 
....................       printf(mostra,"Temperatura: %.1lfC   ",temperatura); 
0B8E:  CLRF   12
0B90:  MOVF   12,W
0B92:  CALL   0004
0B96:  INCF   12,F
0B98:  MOVWF  00
0B9A:  MOVWF  20
0B9C:  RCALL  0510
0B9E:  MOVLW  0D
0BA0:  SUBWF  12,W
0BA2:  BNZ   0B90
0BA4:  MOVLW  89
0BA6:  MOVWF  FE9
0BA8:  MOVFF  11,16
0BAC:  MOVFF  10,15
0BB0:  MOVFF  0F,14
0BB4:  MOVFF  0E,13
0BB8:  MOVLW  01
0BBA:  MOVWF  17
0BBC:  BRA    06CA
0BBE:  MOVLW  12
0BC0:  MOVWF  13
0BC2:  MOVF   13,W
0BC4:  CALL   0004
0BC8:  INCF   13,F
0BCA:  MOVWF  00
0BCC:  MOVWF  20
0BCE:  RCALL  0510
0BD0:  MOVLW  16
0BD2:  SUBWF  13,W
0BD4:  BNZ   0BC2
....................        
....................       //envia o cursor do LCD para a posicao 1,0 
....................       display(0,0xC0); 
0BD6:  CLRF   21
0BD8:  MOVLW  C0
0BDA:  MOVWF  22
0BDC:  CALL   03B4
....................  
....................       //imprime na tela a temperatura 
....................       update_clock(); 
0BE0:  BRA    09DA
....................  
....................       //alterna o estado do pino D4 
....................       output_toggle(PIN_a4); 
0BE2:  BCF    F92.4
0BE4:  BTG    F89.4
....................  
....................       //aguarda 500ms 
....................       delay_ms (500); 
0BE6:  MOVLW  02
0BE8:  MOVWF  12
0BEA:  MOVLW  FA
0BEC:  MOVWF  13
0BEE:  CALL   0374
0BF2:  DECFSZ 12,F
0BF4:  BRA    0BEA
....................    } 
0BF6:  BRA    0B5E
.................... } 
....................  
.................... update_clock(){ 
....................     //ds1307_get_date(day,month,yr,dow);  
0BF8:  SLEEP 
....................     ds1307_get_time(hrs,min,sec);  
....................        
....................     sec = ds1307_read_byte(0); 
*
0AA2:  CLRF   12
0AA4:  BRA    084A
0AA6:  MOVFF  01,05
....................     sec = bcd2bin(sec); 
0AAA:  MOVFF  05,17
0AAE:  CALL   0124
0AB2:  MOVFF  01,05
....................        
....................     //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................     printf(mostra,"Hora: \%02d:\%02d:\%02d", hrs,min,sec);  
0AB6:  CLRF   12
0AB8:  MOVF   12,W
0ABA:  CALL   002C
0ABE:  INCF   12,F
0AC0:  MOVWF  00
0AC2:  MOVWF  20
0AC4:  RCALL  0510
0AC6:  MOVLW  06
0AC8:  SUBWF  12,W
0ACA:  BNZ   0AB8
0ACC:  MOVFF  07,13
0AD0:  MOVLW  01
0AD2:  MOVWF  14
0AD4:  RCALL  0912
0AD6:  MOVLW  3A
0AD8:  MOVWF  20
0ADA:  RCALL  0510
0ADC:  MOVFF  06,13
0AE0:  MOVLW  01
0AE2:  MOVWF  14
0AE4:  RCALL  0912
0AE6:  MOVLW  3A
0AE8:  MOVWF  20
0AEA:  RCALL  0510
0AEC:  MOVFF  05,13
0AF0:  MOVLW  01
0AF2:  MOVWF  14
0AF4:  RCALL  0912
.................... } 
0AF6:  GOTO   0BE2 (RETURN)

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
