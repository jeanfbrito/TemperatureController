CCS PCH C Compiler, Version 4.057, 8241               13-mai-13 23:28

               Filename: main.lst

               ROM used: 6086 bytes (19%)
                         Largest free fragment is 26682
               RAM used: 21 (1%) at main() level
                         48 (3%) worst case
               Stack:    4 locations

*
0000:  GOTO   1718
.................... #include <18f452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(clock=20000000) 
*
0466:  CLRF   FEA
0468:  MOVLW  15
046A:  MOVWF  FE9
046C:  MOVF   FEF,W
046E:  BZ    048A
0470:  MOVLW  06
0472:  MOVWF  01
0474:  CLRF   00
0476:  DECFSZ 00,F
0478:  BRA    0476
047A:  DECFSZ 01,F
047C:  BRA    0474
047E:  MOVLW  7B
0480:  MOVWF  00
0482:  DECFSZ 00,F
0484:  BRA    0482
0486:  DECFSZ FEF,F
0488:  BRA    0470
048A:  RETLW  00
048C:  MOVLW  03
048E:  SUBWF  15,F
0490:  BNC   04A4
0492:  CLRF   FEA
0494:  MOVLW  15
0496:  MOVWF  FE9
0498:  MOVF   FEF,W
049A:  BZ    04A4
049C:  BRA    04A0
049E:  BRA    04A0
04A0:  DECFSZ FEF,F
04A2:  BRA    049E
04A4:  RETLW  00
.................... #fuses HS,NOWDT,PUT 
.................... #include <lcd_generico.c> 
.................... /* 
....................  
.................... Função para utilização do display LCD para qualquer tamanho 
....................  
....................    inic_display();                        função para configurar e inicializar o display 
....................    display(char tipo,char dado);          função para enviar um comando ou um dado para o display 
....................    mostra(char dado);                     funçao para enviar um dado para o display 
....................  
....................    Configuração dos pinos do microcontrolador 
....................  
....................    RB0 = enable display 
....................    RB1 = RS 
....................    RB2 = RW 
....................    RB3 = 
....................    RB4 = DB4 
....................    RB5 = DB5 
....................    RB6 = DB6 
....................    RB7 = DB7 
....................  
....................    Primeira linha = 0x80 
....................    Segunda  linha = 0xC0 
....................    Terceira linha = 0xA0 
....................    Quarta linha   = 0xE0 
....................  
.................... Aprimorado por Cleber Toss Hoffmann 
.................... cleber.toss.hoffmann@gmail.com 
....................  
.................... */ 
.................... // 
.................... #byte PORTB=0xF81 
.................... #byte TRISB=0xF93 
....................  
.................... //Constantes 
.................... #define set_bit0 0x01 
.................... #define set_bit1 0x02 
.................... #define set_bit2 0x04 
....................  
.................... #define clear_bit0 0xfe 
.................... #define clear_bit1 0xfd 
.................... #define clear_bit2 0xfb 
....................  
.................... void inic_display(); 
....................  
.................... #separate 
.................... void display(char tipo,char dado); 
....................  
.................... #separate 
.................... void mostra(char dado); 
....................  
.................... void inic_display() 
.................... { 
....................  TRISB =0x00; 
*
0522:  CLRF   F93
....................  delay_ms(50); 
0524:  MOVLW  32
0526:  MOVWF  15
0528:  RCALL  0466
....................  
....................  PORTB  = 0x30; 
052A:  MOVLW  30
052C:  MOVWF  F81
....................  PORTB |= set_bit0; 
052E:  BSF    F81.0
....................  delay_us(5); 
0530:  MOVLW  08
0532:  MOVWF  00
0534:  DECFSZ 00,F
0536:  BRA    0534
....................  PORTB &= clear_bit0; 
0538:  BCF    F81.0
....................  delay_ms(25); 
053A:  MOVLW  19
053C:  MOVWF  15
053E:  RCALL  0466
....................  
....................  PORTB = 0x30; 
0540:  MOVLW  30
0542:  MOVWF  F81
....................  PORTB |= set_bit0; 
0544:  BSF    F81.0
....................  delay_us(5); 
0546:  MOVLW  08
0548:  MOVWF  00
054A:  DECFSZ 00,F
054C:  BRA    054A
....................  PORTB &= clear_bit0; 
054E:  BCF    F81.0
....................  delay_ms(25); 
0550:  MOVLW  19
0552:  MOVWF  15
0554:  RCALL  0466
....................  
....................  PORTB = 0x30; 
0556:  MOVLW  30
0558:  MOVWF  F81
....................  PORTB |= set_bit0; 
055A:  BSF    F81.0
....................  delay_us(5); 
055C:  MOVLW  08
055E:  MOVWF  00
0560:  DECFSZ 00,F
0562:  BRA    0560
....................  PORTB &= clear_bit0; 
0564:  BCF    F81.0
....................  delay_ms(25); 
0566:  MOVLW  19
0568:  MOVWF  15
056A:  RCALL  0466
....................  
....................  PORTB = 0x30; 
056C:  MOVLW  30
056E:  MOVWF  F81
....................  PORTB |= set_bit0; 
0570:  BSF    F81.0
....................  delay_us(5); 
0572:  MOVLW  08
0574:  MOVWF  00
0576:  DECFSZ 00,F
0578:  BRA    0576
....................  PORTB &= clear_bit0; 
057A:  BCF    F81.0
....................  
....................  delay_us(200); 
057C:  MOVLW  C8
057E:  MOVWF  15
0580:  RCALL  048C
....................  PORTB = 0x20; 
0582:  MOVLW  20
0584:  MOVWF  F81
....................  PORTB |= set_bit0; 
0586:  BSF    F81.0
....................  delay_us(5); 
0588:  MOVLW  08
058A:  MOVWF  00
058C:  DECFSZ 00,F
058E:  BRA    058C
....................  PORTB &= clear_bit0; 
0590:  BCF    F81.0
....................  
....................  delay_us(200); 
0592:  MOVLW  C8
0594:  MOVWF  15
0596:  RCALL  048C
....................  display(0,0x28); 
0598:  CLRF   24
059A:  MOVLW  28
059C:  MOVWF  25
059E:  RCALL  04A6
....................  display(0,0x08); 
05A0:  CLRF   24
05A2:  MOVLW  08
05A4:  MOVWF  25
05A6:  RCALL  04A6
....................  display(0,0x01); 
05A8:  CLRF   24
05AA:  MOVLW  01
05AC:  MOVWF  25
05AE:  RCALL  04A6
....................  delay_ms(5); 
05B0:  MOVLW  05
05B2:  MOVWF  15
05B4:  RCALL  0466
....................  display(0,0x06); 
05B6:  CLRF   24
05B8:  MOVLW  06
05BA:  MOVWF  25
05BC:  RCALL  04A6
....................  display(0,0x0c); 
05BE:  CLRF   24
05C0:  MOVLW  0C
05C2:  MOVWF  25
05C4:  RCALL  04A6
....................  
.................... } 
05C6:  GOTO   1766 (RETURN)
....................  
....................  
.................... /* display 
....................    Envia um dado para o display. 
....................    Se tipo=0, é um comando (RS=0) 
....................    Se tipo=1, é um dado (RS=1) 
.................... */ 
.................... #separate 
.................... void display(char tipo,char dado) 
.................... { 
....................  char temp; 
....................  if(tipo == true) 
*
04A6:  DECFSZ 24,W
04A8:  BRA    04EA
....................     { 
....................      temp=(dado & 0xf0) | set_bit1; 
04AA:  MOVF   25,W
04AC:  ANDLW  F0
04AE:  IORLW  02
04B0:  MOVWF  26
....................      PORTB = temp; 
04B2:  MOVFF  26,F81
....................      PORTB |= set_bit0; 
04B6:  BSF    F81.0
....................      delay_us(5); 
04B8:  MOVLW  08
04BA:  MOVWF  00
04BC:  DECFSZ 00,F
04BE:  BRA    04BC
....................      PORTB &= clear_bit0; 
04C0:  BCF    F81.0
.................... //   delay_us(50); 
....................      temp=(dado << 4) | set_bit1; 
04C2:  SWAPF  25,W
04C4:  MOVWF  00
04C6:  MOVLW  F0
04C8:  ANDWF  00,F
04CA:  MOVF   00,W
04CC:  IORLW  02
04CE:  MOVWF  26
....................      PORTB = temp; 
04D0:  MOVFF  26,F81
....................      PORTB |= set_bit0; 
04D4:  BSF    F81.0
....................      delay_us(5); 
04D6:  MOVLW  08
04D8:  MOVWF  00
04DA:  DECFSZ 00,F
04DC:  BRA    04DA
....................      PORTB &= clear_bit0; 
04DE:  BCF    F81.0
....................      delay_us(50); 
04E0:  MOVLW  53
04E2:  MOVWF  00
04E4:  DECFSZ 00,F
04E6:  BRA    04E4
....................  
....................     } 
....................  else 
04E8:  BRA    0520
....................     { 
....................      temp=(dado & 0xf0); 
04EA:  MOVF   25,W
04EC:  ANDLW  F0
04EE:  MOVWF  26
....................      PORTB = temp; 
04F0:  MOVFF  26,F81
....................      PORTB |= set_bit0; 
04F4:  BSF    F81.0
....................      delay_us(5); 
04F6:  MOVLW  08
04F8:  MOVWF  00
04FA:  DECFSZ 00,F
04FC:  BRA    04FA
....................      PORTB &= clear_bit0; 
04FE:  BCF    F81.0
.................... //   delay_us(50); 
....................      temp=(dado << 4); 
0500:  SWAPF  25,W
0502:  MOVWF  26
0504:  MOVLW  F0
0506:  ANDWF  26,F
....................      PORTB = temp; 
0508:  MOVFF  26,F81
....................      PORTB |= set_bit0; 
050C:  BSF    F81.0
....................      delay_us(5); 
050E:  MOVLW  08
0510:  MOVWF  00
0512:  DECFSZ 00,F
0514:  BRA    0512
....................      PORTB &= clear_bit0; 
0516:  BCF    F81.0
....................      delay_us(50); 
0518:  MOVLW  53
051A:  MOVWF  00
051C:  DECFSZ 00,F
051E:  BRA    051C
....................     } 
....................  
.................... } 
0520:  RETLW  00
....................  
.................... #separate 
.................... void mostra(char dado) 
.................... { 
....................  display(1,dado); 
*
0D58:  MOVLW  01
0D5A:  MOVWF  24
0D5C:  MOVFF  23,25
0D60:  CALL   04A6
.................... } 
0D64:  RETLW  00
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #IF !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #ENDIF 
....................  
.................... #IF defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #ENDIF 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #IF defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    int8  data1,data2; 
....................    #endif 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #IF !defined(__PCD__) 
....................      *((unsigned int8 *)(&y)) = 0x7E;  
.................... #ENDIF 
....................  
.................... #IF defined(__PCD__) // Takes care of IEEE format 
.................... *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................  *(((unsigned int8 *)(&y))+2) = data1; 
.................... #ENDIF 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #IF !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #ENDIF 
.................... #IF defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
.................... { 
....................      bit_set(data1,0); 
.................... } 
....................     n = data1 - 0x7E; 
.................... #ENDIF 
....................  
....................       if (n<0) 
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................  *(((unsigned int8 *)(&y))+2) = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
.................... { 
....................      bit_set(data1,0); 
.................... } 
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................  *(((unsigned int8 *)(&y))+2) = data1; 
....................  
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................   
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
.................... { 
....................      bit_set(data1,0); 
.................... } 
....................     n = data1 - 0x7E; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int8 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................    data1--; 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(___PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int8 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................    data1--; 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................       (*p)--; 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "ds1307.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                               DS1307.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RTC_SDA  PIN_C4  
.................... #define RTC_SCL  PIN_C3  
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL)  
*
0212:  MOVLW  08
0214:  MOVWF  01
0216:  MOVLW  05
0218:  MOVWF  00
021A:  DECFSZ 00,F
021C:  BRA    021A
021E:  BCF    F8B.3
0220:  BCF    F94.3
0222:  MOVLW  06
0224:  MOVWF  00
0226:  DECFSZ 00,F
0228:  BRA    0226
022A:  RLCF   1D,F
022C:  BCF    F8B.4
022E:  BTFSC  FD8.0
0230:  BSF    F94.4
0232:  BTFSS  FD8.0
0234:  BCF    F94.4
0236:  BSF    F94.3
0238:  BTFSS  F82.3
023A:  BRA    0238
023C:  DECFSZ 01,F
023E:  BRA    0216
0240:  MOVLW  05
0242:  MOVWF  00
0244:  DECFSZ 00,F
0246:  BRA    0244
0248:  BCF    F8B.3
024A:  BCF    F94.3
024C:  NOP   
024E:  BSF    F94.4
0250:  MOVLW  06
0252:  MOVWF  00
0254:  DECFSZ 00,F
0256:  BRA    0254
0258:  MOVLW  06
025A:  MOVWF  00
025C:  DECFSZ 00,F
025E:  BRA    025C
0260:  BSF    F94.3
0262:  BTFSS  F82.3
0264:  BRA    0262
0266:  CLRF   01
0268:  MOVLW  06
026A:  MOVWF  00
026C:  DECFSZ 00,F
026E:  BRA    026C
0270:  BTFSC  F82.4
0272:  BSF    01.0
0274:  BCF    F8B.3
0276:  BCF    F94.3
0278:  BCF    F8B.4
027A:  BCF    F94.4
027C:  RETLW  00
027E:  MOVLW  08
0280:  MOVWF  1A
0282:  MOVFF  00,1B
0286:  BSF    F94.4
0288:  MOVLW  06
028A:  MOVWF  00
028C:  DECFSZ 00,F
028E:  BRA    028C
0290:  BSF    F94.3
0292:  BTFSS  F82.3
0294:  BRA    0292
0296:  BTFSC  F82.4
0298:  BSF    FD8.0
029A:  BTFSS  F82.4
029C:  BCF    FD8.0
029E:  RLCF   01,F
02A0:  MOVLW  05
02A2:  MOVWF  00
02A4:  DECFSZ 00,F
02A6:  BRA    02A4
02A8:  BCF    F94.3
02AA:  BCF    F8B.3
02AC:  DECFSZ 1A,F
02AE:  BRA    0286
02B0:  BSF    F94.4
02B2:  MOVLW  06
02B4:  MOVWF  00
02B6:  DECFSZ 00,F
02B8:  BRA    02B6
02BA:  BCF    F8B.4
02BC:  MOVF   1B,W
02BE:  BTFSS  FD8.2
02C0:  BCF    F94.4
02C2:  NOP   
02C4:  BSF    F94.3
02C6:  BTFSS  F82.3
02C8:  BRA    02C6
02CA:  MOVLW  05
02CC:  MOVWF  00
02CE:  DECFSZ 00,F
02D0:  BRA    02CE
02D2:  BCF    F8B.3
02D4:  BCF    F94.3
02D6:  MOVLW  06
02D8:  MOVWF  00
02DA:  DECFSZ 00,F
02DC:  BRA    02DA
02DE:  BCF    F8B.4
02E0:  BCF    F94.4
02E2:  RETLW  00
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);  
....................  
.................... void ds1307_init(void)  
.................... {  
....................    BYTE seconds = 0;  
*
032E:  CLRF   15
....................  
....................    i2c_start();  
0330:  BSF    F94.4
0332:  MOVLW  05
0334:  MOVWF  00
0336:  DECFSZ 00,F
0338:  BRA    0336
033A:  BSF    F94.3
033C:  MOVLW  06
033E:  MOVWF  00
0340:  DECFSZ 00,F
0342:  BRA    0340
0344:  BCF    F8B.4
0346:  BCF    F94.4
0348:  MOVLW  05
034A:  MOVWF  00
034C:  DECFSZ 00,F
034E:  BRA    034C
0350:  BCF    F8B.3
0352:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
0354:  MOVLW  D0
0356:  MOVWF  1D
0358:  RCALL  0212
....................    i2c_write(0x00);      // REG 0  
035A:  CLRF   1D
035C:  RCALL  0212
....................    i2c_start();  
035E:  BSF    F94.4
0360:  MOVLW  05
0362:  MOVWF  00
0364:  DECFSZ 00,F
0366:  BRA    0364
0368:  BSF    F94.3
036A:  MOVLW  06
036C:  MOVWF  00
036E:  DECFSZ 00,F
0370:  BRA    036E
0372:  BTFSS  F82.3
0374:  BRA    0372
0376:  BCF    F8B.4
0378:  BCF    F94.4
037A:  MOVLW  05
037C:  MOVWF  00
037E:  DECFSZ 00,F
0380:  BRA    037E
0382:  BCF    F8B.3
0384:  BCF    F94.3
....................    i2c_write(0xD1);      // RD from RTC  
0386:  MOVLW  D1
0388:  MOVWF  1D
038A:  RCALL  0212
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
038C:  CLRF   00
038E:  RCALL  027E
0390:  MOVFF  01,16
0394:  MOVFF  01,1B
0398:  RCALL  02E4
039A:  MOVFF  01,15
....................    i2c_stop();  
039E:  BCF    F94.4
03A0:  NOP   
03A2:  BSF    F94.3
03A4:  BTFSS  F82.3
03A6:  BRA    03A4
03A8:  MOVLW  05
03AA:  MOVWF  00
03AC:  DECFSZ 00,F
03AE:  BRA    03AC
03B0:  BRA    03B2
03B2:  NOP   
03B4:  BSF    F94.4
03B6:  MOVLW  05
03B8:  MOVWF  00
03BA:  DECFSZ 00,F
03BC:  BRA    03BA
....................    seconds &= 0x7F;  
03BE:  BCF    15.7
....................  
....................    delay_us(3);  
03C0:  MOVLW  04
03C2:  MOVWF  00
03C4:  DECFSZ 00,F
03C6:  BRA    03C4
03C8:  BRA    03CA
....................  
....................    i2c_start();  
03CA:  BSF    F94.4
03CC:  MOVLW  05
03CE:  MOVWF  00
03D0:  DECFSZ 00,F
03D2:  BRA    03D0
03D4:  BSF    F94.3
03D6:  MOVLW  06
03D8:  MOVWF  00
03DA:  DECFSZ 00,F
03DC:  BRA    03DA
03DE:  BCF    F8B.4
03E0:  BCF    F94.4
03E2:  MOVLW  05
03E4:  MOVWF  00
03E6:  DECFSZ 00,F
03E8:  BRA    03E6
03EA:  BCF    F8B.3
03EC:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
03EE:  MOVLW  D0
03F0:  MOVWF  1D
03F2:  RCALL  0212
....................    i2c_write(0x00);      // REG 0  
03F4:  CLRF   1D
03F6:  RCALL  0212
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
03F8:  MOVFF  15,1C
03FC:  RCALL  030A
03FE:  MOVFF  01,16
0402:  MOVFF  01,1D
0406:  RCALL  0212
....................    i2c_start();  
0408:  BSF    F94.4
040A:  MOVLW  05
040C:  MOVWF  00
040E:  DECFSZ 00,F
0410:  BRA    040E
0412:  BSF    F94.3
0414:  MOVLW  06
0416:  MOVWF  00
0418:  DECFSZ 00,F
041A:  BRA    0418
041C:  BTFSS  F82.3
041E:  BRA    041C
0420:  BCF    F8B.4
0422:  BCF    F94.4
0424:  MOVLW  05
0426:  MOVWF  00
0428:  DECFSZ 00,F
042A:  BRA    0428
042C:  BCF    F8B.3
042E:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
0430:  MOVLW  D0
0432:  MOVWF  1D
0434:  RCALL  0212
....................    i2c_write(0x07);      // Control Register  
0436:  MOVLW  07
0438:  MOVWF  1D
043A:  RCALL  0212
....................    i2c_write(0x80);     // Disable squarewave output pin  
043C:  MOVLW  80
043E:  MOVWF  1D
0440:  RCALL  0212
....................    i2c_stop();  
0442:  BCF    F94.4
0444:  NOP   
0446:  BSF    F94.3
0448:  BTFSS  F82.3
044A:  BRA    0448
044C:  MOVLW  05
044E:  MOVWF  00
0450:  DECFSZ 00,F
0452:  BRA    0450
0454:  BRA    0456
0456:  NOP   
0458:  BSF    F94.4
045A:  MOVLW  05
045C:  MOVWF  00
045E:  DECFSZ 00,F
0460:  BRA    045E
....................  
.................... }  
0462:  GOTO   173A (RETURN)
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... {  
....................   sec &= 0x7F;  
*
120A:  BCF    1B.7
....................   hr &= 0x3F;  
120C:  MOVLW  3F
120E:  ANDWF  19,F
....................  
....................   i2c_start();  
1210:  BSF    F94.4
1212:  MOVLW  05
1214:  MOVWF  00
1216:  DECFSZ 00,F
1218:  BRA    1216
121A:  BSF    F94.3
121C:  MOVLW  06
121E:  MOVWF  00
1220:  DECFSZ 00,F
1222:  BRA    1220
1224:  BCF    F8B.4
1226:  BCF    F94.4
1228:  MOVLW  05
122A:  MOVWF  00
122C:  DECFSZ 00,F
122E:  BRA    122C
1230:  BCF    F8B.3
1232:  BCF    F94.3
....................   i2c_write(0xD0);            // I2C write address  
1234:  MOVLW  D0
1236:  MOVWF  1D
1238:  CALL   0212
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
123C:  CLRF   1D
123E:  CALL   0212
....................   i2c_write(bin2bcd(sec));      // REG 0  
1242:  MOVFF  1B,1C
1246:  CALL   030A
124A:  MOVFF  01,1C
124E:  MOVFF  01,1D
1252:  CALL   0212
....................   i2c_write(bin2bcd(min));      // REG 1  
1256:  MOVFF  1A,1C
125A:  CALL   030A
125E:  MOVFF  01,1C
1262:  MOVFF  01,1D
1266:  CALL   0212
....................   i2c_write(bin2bcd(hr));      // REG 2  
126A:  MOVFF  19,1C
126E:  CALL   030A
1272:  MOVFF  01,1C
1276:  MOVFF  01,1D
127A:  CALL   0212
....................   i2c_write(bin2bcd(dow));      // REG 3  
127E:  MOVFF  18,1C
1282:  CALL   030A
1286:  MOVFF  01,1C
128A:  MOVFF  01,1D
128E:  CALL   0212
....................   i2c_write(bin2bcd(day));      // REG 4  
1292:  MOVFF  15,1C
1296:  CALL   030A
129A:  MOVFF  01,1C
129E:  MOVFF  01,1D
12A2:  CALL   0212
....................   i2c_write(bin2bcd(mth));      // REG 5  
12A6:  MOVFF  16,1C
12AA:  CALL   030A
12AE:  MOVFF  01,1C
12B2:  MOVFF  01,1D
12B6:  CALL   0212
....................   i2c_write(bin2bcd(year));      // REG 6  
12BA:  MOVFF  17,1C
12BE:  CALL   030A
12C2:  MOVFF  01,1C
12C6:  MOVFF  01,1D
12CA:  CALL   0212
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
12CE:  MOVLW  80
12D0:  MOVWF  1D
12D2:  CALL   0212
....................   i2c_stop();  
12D6:  BCF    F94.4
12D8:  NOP   
12DA:  BSF    F94.3
12DC:  BTFSS  F82.3
12DE:  BRA    12DC
12E0:  MOVLW  05
12E2:  MOVWF  00
12E4:  DECFSZ 00,F
12E6:  BRA    12E4
12E8:  BRA    12EA
12EA:  NOP   
12EC:  BSF    F94.4
12EE:  MOVLW  05
12F0:  MOVWF  00
12F2:  DECFSZ 00,F
12F4:  BRA    12F2
.................... }  
12F6:  GOTO   16D8 (RETURN)
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow)  
.................... {  
....................   i2c_start();  
*
0664:  BSF    F94.4
0666:  MOVLW  05
0668:  MOVWF  00
066A:  DECFSZ 00,F
066C:  BRA    066A
066E:  BSF    F94.3
0670:  MOVLW  06
0672:  MOVWF  00
0674:  DECFSZ 00,F
0676:  BRA    0674
0678:  BCF    F8B.4
067A:  BCF    F94.4
067C:  MOVLW  05
067E:  MOVWF  00
0680:  DECFSZ 00,F
0682:  BRA    0680
0684:  BCF    F8B.3
0686:  BCF    F94.3
....................   i2c_write(0xD0);  
0688:  MOVLW  D0
068A:  MOVWF  1D
068C:  RCALL  0212
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
068E:  MOVLW  03
0690:  MOVWF  1D
0692:  RCALL  0212
....................   i2c_start();  
0694:  BSF    F94.4
0696:  MOVLW  05
0698:  MOVWF  00
069A:  DECFSZ 00,F
069C:  BRA    069A
069E:  BSF    F94.3
06A0:  MOVLW  06
06A2:  MOVWF  00
06A4:  DECFSZ 00,F
06A6:  BRA    06A4
06A8:  BTFSS  F82.3
06AA:  BRA    06A8
06AC:  BCF    F8B.4
06AE:  BCF    F94.4
06B0:  MOVLW  05
06B2:  MOVWF  00
06B4:  DECFSZ 00,F
06B6:  BRA    06B4
06B8:  BCF    F8B.3
06BA:  BCF    F94.3
....................   i2c_write(0xD1);  
06BC:  MOVLW  D1
06BE:  MOVWF  1D
06C0:  RCALL  0212
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
06C2:  MOVLW  01
06C4:  MOVWF  00
06C6:  RCALL  027E
06C8:  MOVF   01,W
06CA:  ANDLW  7F
06CC:  MOVWF  16
06CE:  MOVWF  1B
06D0:  RCALL  02E4
06D2:  MOVFF  01,0B
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
06D6:  MOVLW  01
06D8:  MOVWF  00
06DA:  RCALL  027E
06DC:  MOVF   01,W
06DE:  ANDLW  3F
06E0:  MOVWF  16
06E2:  MOVWF  1B
06E4:  RCALL  02E4
06E6:  MOVFF  01,08
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
06EA:  MOVLW  01
06EC:  MOVWF  00
06EE:  RCALL  027E
06F0:  MOVF   01,W
06F2:  ANDLW  1F
06F4:  MOVWF  16
06F6:  MOVWF  1B
06F8:  RCALL  02E4
06FA:  MOVFF  01,09
....................   year = bcd2bin(i2c_read(0));            // REG 6  
06FE:  CLRF   00
0700:  RCALL  027E
0702:  MOVFF  01,15
0706:  MOVFF  01,1B
070A:  RCALL  02E4
070C:  MOVFF  01,0A
....................   i2c_stop();  
0710:  BCF    F94.4
0712:  NOP   
0714:  BSF    F94.3
0716:  BTFSS  F82.3
0718:  BRA    0716
071A:  MOVLW  05
071C:  MOVWF  00
071E:  DECFSZ 00,F
0720:  BRA    071E
0722:  BRA    0724
0724:  NOP   
0726:  BSF    F94.4
0728:  MOVLW  05
072A:  MOVWF  00
072C:  DECFSZ 00,F
072E:  BRA    072C
.................... }  
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   i2c_start();  
0730:  BSF    F94.4
0732:  MOVLW  05
0734:  MOVWF  00
0736:  DECFSZ 00,F
0738:  BRA    0736
073A:  BSF    F94.3
073C:  MOVLW  06
073E:  MOVWF  00
0740:  DECFSZ 00,F
0742:  BRA    0740
0744:  BCF    F8B.4
0746:  BCF    F94.4
0748:  MOVLW  05
074A:  MOVWF  00
074C:  DECFSZ 00,F
074E:  BRA    074C
0750:  BCF    F8B.3
0752:  BCF    F94.3
....................   i2c_write(0xD0);  
0754:  MOVLW  D0
0756:  MOVWF  1D
0758:  RCALL  0212
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
075A:  CLRF   1D
075C:  RCALL  0212
....................   i2c_start();  
075E:  BSF    F94.4
0760:  MOVLW  05
0762:  MOVWF  00
0764:  DECFSZ 00,F
0766:  BRA    0764
0768:  BSF    F94.3
076A:  MOVLW  06
076C:  MOVWF  00
076E:  DECFSZ 00,F
0770:  BRA    076E
0772:  BTFSS  F82.3
0774:  BRA    0772
0776:  BCF    F8B.4
0778:  BCF    F94.4
077A:  MOVLW  05
077C:  MOVWF  00
077E:  DECFSZ 00,F
0780:  BRA    077E
0782:  BCF    F8B.3
0784:  BCF    F94.3
....................   i2c_write(0xD1);  
0786:  MOVLW  D1
0788:  MOVWF  1D
078A:  RCALL  0212
....................   sec = bcd2bin(i2c_read() & 0x7f);  
078C:  MOVLW  01
078E:  MOVWF  00
0790:  RCALL  027E
0792:  MOVF   01,W
0794:  ANDLW  7F
0796:  MOVWF  16
0798:  MOVWF  1B
079A:  RCALL  02E4
079C:  MOVFF  01,05
....................   min = bcd2bin(i2c_read() & 0x7f);  
07A0:  MOVLW  01
07A2:  MOVWF  00
07A4:  RCALL  027E
07A6:  MOVF   01,W
07A8:  ANDLW  7F
07AA:  MOVWF  16
07AC:  MOVWF  1B
07AE:  RCALL  02E4
07B0:  MOVFF  01,06
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
07B4:  CLRF   00
07B6:  RCALL  027E
07B8:  MOVF   01,W
07BA:  ANDLW  3F
07BC:  MOVWF  16
07BE:  MOVWF  1B
07C0:  RCALL  02E4
07C2:  MOVFF  01,07
....................   i2c_stop();  
07C6:  BCF    F94.4
07C8:  NOP   
07CA:  BSF    F94.3
07CC:  BTFSS  F82.3
07CE:  BRA    07CC
07D0:  MOVLW  05
07D2:  MOVWF  00
07D4:  DECFSZ 00,F
07D6:  BRA    07D4
07D8:  BRA    07DA
07DA:  NOP   
07DC:  BSF    F94.4
07DE:  MOVLW  05
07E0:  MOVWF  00
07E2:  DECFSZ 00,F
07E4:  BRA    07E2
....................  
.................... }  
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................   BYTE temp;  
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
030A:  MOVFF  1C,1D
....................   retval = 0;  
030E:  CLRF   1E
....................  
....................   while(1)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
0310:  MOVF   1D,W
0312:  SUBLW  09
0314:  BC    0320
....................     {  
....................       temp -= 10;  
0316:  MOVLW  0A
0318:  SUBWF  1D,F
....................       retval += 0x10;  
031A:  MOVLW  10
031C:  ADDWF  1E,F
....................     }  
....................     else // Get the ones digit by adding the remainder.  
031E:  BRA    0326
....................     {  
....................       retval += temp;  
0320:  MOVF   1D,W
0322:  ADDWF  1E,F
....................       break;  
0324:  BRA    0328
....................     }  
....................   }  
0326:  BRA    0310
....................  
....................   return(retval);  
0328:  MOVFF  1E,01
.................... }  
032C:  RETLW  00
....................  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp;  
....................  
....................   temp = bcd_value;  
*
02E4:  MOVFF  1B,1C
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
02E8:  BCF    FD8.0
02EA:  RRCF   1C,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
02EC:  MOVLW  78
02EE:  ANDWF  1C,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f));  
02F0:  RRCF   1C,W
02F2:  MOVWF  00
02F4:  RRCF   00,F
02F6:  MOVLW  3F
02F8:  ANDWF  00,F
02FA:  MOVF   00,W
02FC:  ADDWF  1C,W
02FE:  MOVWF  1D
0300:  MOVF   1B,W
0302:  ANDLW  0F
0304:  ADDWF  1D,W
0306:  MOVWF  01
.................... }  
0308:  RETLW  00
....................  
.................... //------------------------------------------------------------------------ 
.................... // Read one byte at the specified address. 
.................... // This function is used to access the control byte 
.................... // or the NVRAM bytes. 
....................  
.................... char ds1307_read_byte(char addr) 
.................... { 
.................... char retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
05CA:  BCF    FF2.6
05CC:  BCF    FF2.7
05CE:  BTFSC  FF2.7
05D0:  BRA    05CC
.................... i2c_start(); 
05D2:  BSF    F94.4
05D4:  MOVLW  05
05D6:  MOVWF  00
05D8:  DECFSZ 00,F
05DA:  BRA    05D8
05DC:  BSF    F94.3
05DE:  MOVLW  06
05E0:  MOVWF  00
05E2:  DECFSZ 00,F
05E4:  BRA    05E2
05E6:  BCF    F8B.4
05E8:  BCF    F94.4
05EA:  MOVLW  05
05EC:  MOVWF  00
05EE:  DECFSZ 00,F
05F0:  BRA    05EE
05F2:  BCF    F8B.3
05F4:  BCF    F94.3
.................... i2c_write(0xD0); 
05F6:  MOVLW  D0
05F8:  MOVWF  1D
05FA:  RCALL  0212
.................... i2c_write(addr); 
05FC:  MOVFF  15,1D
0600:  RCALL  0212
....................  
.................... i2c_start(); 
0602:  BSF    F94.4
0604:  MOVLW  05
0606:  MOVWF  00
0608:  DECFSZ 00,F
060A:  BRA    0608
060C:  BSF    F94.3
060E:  MOVLW  06
0610:  MOVWF  00
0612:  DECFSZ 00,F
0614:  BRA    0612
0616:  BTFSS  F82.3
0618:  BRA    0616
061A:  BCF    F8B.4
061C:  BCF    F94.4
061E:  MOVLW  05
0620:  MOVWF  00
0622:  DECFSZ 00,F
0624:  BRA    0622
0626:  BCF    F8B.3
0628:  BCF    F94.3
.................... i2c_write(0xD1); 
062A:  MOVLW  D1
062C:  MOVWF  1D
062E:  RCALL  0212
.................... retval = i2c_read(0);   // Don't ACK the last byte read 
0630:  CLRF   00
0632:  RCALL  027E
0634:  MOVFF  01,16
.................... i2c_stop(); 
0638:  BCF    F94.4
063A:  NOP   
063C:  BSF    F94.3
063E:  BTFSS  F82.3
0640:  BRA    063E
0642:  MOVLW  05
0644:  MOVWF  00
0646:  DECFSZ 00,F
0648:  BRA    0646
064A:  BRA    064C
064C:  NOP   
064E:  BSF    F94.4
0650:  MOVLW  05
0652:  MOVWF  00
0654:  DECFSZ 00,F
0656:  BRA    0654
.................... enable_interrupts(GLOBAL); 
0658:  MOVLW  C0
065A:  IORWF  FF2,F
....................  
.................... return(retval); 
065C:  MOVFF  16,01
.................... } 
0660:  GOTO   07EA (RETURN)
....................  
....................  
....................  
.................... #define TECLA_SET    !input(PIN_D0) 
.................... #define TECLA_MAIS   !input(PIN_D3) 
.................... #define TECLA_MENOS  !input(PIN_D2) 
....................  
.................... #define SAIDA01 PIN_D1 
....................  
.................... #define POTENTIAL_DIVIDER_RESISTOR 10000 
.................... #define THERMISTOR_B_VALUE 3977 
.................... #define THERMISTOR_REF_TEMP 298.15 
.................... #define THERMISTOR_REF_RESISTANCE 10000 
....................  
.................... BYTE sec;  
.................... BYTE min;  
.................... BYTE hrs;  
.................... BYTE day;  
.................... BYTE month;  
.................... BYTE yr;  
.................... BYTE dow;  
.................... int temperatura_maxima = 30; 
.................... int tela = 0; //0-Tela principal, 1-Config. Temperatura, 2-Config. Horario 
.................... float temperatura; 
....................  
.................... int histerese = 3; 
....................  
.................... update_clock();  
.................... read_temperature(); 
.................... check_temperature(); 
.................... show_clock(); 
.................... show_temperature(); 
.................... configure_temperature(); 
.................... configure_time(); 
....................  
.................... main() 
.................... {  
*
1718:  CLRF   FF8
171A:  BCF    FD0.7
171C:  CLRF   FEA
171E:  CLRF   FE9
1720:  BSF    FC1.0
1722:  BSF    FC1.1
1724:  BSF    FC1.2
1726:  BCF    FC1.3
1728:  MOVLW  1E
172A:  MOVWF  0C
172C:  CLRF   0D
172E:  MOVLW  03
1730:  MOVWF  12
1732:  CLRF   13
1734:  CLRF   14
.................... ds1307_init();  
1736:  GOTO   032E
....................  
.................... // Set date for -> 15 June 2005 Tuesday  
.................... // Set time for -> 15:20:55  
.................... //ds1307_set_date_time(18,11,12,2,22,05,55);  
....................  
....................  
....................   setup_adc(ADC_CLOCK_INTERNAL); 
173A:  BCF    FC1.6
173C:  BSF    FC2.6
173E:  BSF    FC2.7
1740:  BSF    FC1.7
1742:  BSF    FC2.0
.................... //enables the a/d module  
....................   set_adc_channel(0); 
1744:  MOVLW  00
1746:  MOVWF  01
1748:  MOVF   FC2,W
174A:  ANDLW  C7
174C:  IORWF  01,W
174E:  MOVWF  FC2
.................... //the next read_adc call will read channel 0 
....................   delay_us(10); 
1750:  MOVLW  10
1752:  MOVWF  00
1754:  DECFSZ 00,F
1756:  BRA    1754
1758:  NOP   
.................... //a small delay is required after setting the channel 
....................  
.................... //aguarda 100ms 
....................   delay_ms(100); 
175A:  MOVLW  64
175C:  MOVWF  15
175E:  CALL   0466
....................  
.................... //inicializa o display LCD 
....................   inic_display(); 
1762:  GOTO   0522
....................  
....................   while (true) 
....................   { 
....................  
....................     switch(tela){ 
1766:  MOVF   0D,W
1768:  BZ    1774
176A:  XORLW  01
176C:  BZ    17B2
176E:  XORLW  03
1770:  BZ    17B8
1772:  BRA    17BA
....................       case 0: 
....................         display(0,0x01); 
1774:  CLRF   24
1776:  MOVLW  01
1778:  MOVWF  25
177A:  CALL   04A6
....................         update_clock(); 
177E:  GOTO   0664
....................         read_temperature(); 
1782:  CALL   0C06
....................         check_temperature(); 
1786:  GOTO   0CF0
....................         show_temperature(); 
178A:  BRA    0FA0
....................         show_clock(); 
178C:  BRA    10E4
....................  
....................         if(TECLA_SET) 
178E:  BSF    F95.0
1790:  BTFSC  F83.0
1792:  BRA    179A
....................           tela = 1; 
1794:  MOVLW  01
1796:  MOVWF  0D
....................         else if(TECLA_MAIS) 
1798:  BRA    17B0
179A:  BSF    F95.3
179C:  BTFSC  F83.3
179E:  BRA    17A6
....................           tela = 1; 
17A0:  MOVLW  01
17A2:  MOVWF  0D
....................         else if (TECLA_MENOS) 
17A4:  BRA    17B0
17A6:  BSF    F95.2
17A8:  BTFSC  F83.2
17AA:  BRA    17B0
....................           tela = 2; 
17AC:  MOVLW  02
17AE:  MOVWF  0D
....................  
....................         break; 
17B0:  BRA    17BA
....................       case 1: 
....................         read_temperature(); 
17B2:  CALL   0C06
....................         configure_temperature(); 
17B6:  BRA    114A
....................         break; 
....................       case 2: 
....................         //update_clock(); 
....................         configure_time(); 
17B8:  BRA    12FA
....................         break; 
....................     } 
....................  
.................... //alterna o estado do pino D4 
....................     //output_toggle(PIN_D1); 
....................  
.................... //aguarda 500ms 
....................     delay_ms (200); 
17BA:  MOVLW  C8
17BC:  MOVWF  15
17BE:  CALL   0466
....................   } 
17C2:  BRA    1766
.................... } 
....................  
.................... check_temperature(){ 
....................   if(temperatura < temperatura_maxima - histerese) 
*
0CF0:  MOVF   12,W
0CF2:  SUBWF  0C,W
0CF4:  CLRF   20
0CF6:  MOVWF  1F
0CF8:  RCALL  07FC
0CFA:  MOVFF  11,1E
0CFE:  MOVFF  10,1D
0D02:  MOVFF  0F,1C
0D06:  MOVFF  0E,1B
0D0A:  MOVFF  03,22
0D0E:  MOVFF  02,21
0D12:  MOVFF  01,20
0D16:  MOVFF  00,1F
0D1A:  RCALL  0924
0D1C:  BNC   0D24
*
17C4:  SLEEP 
....................     output_high(SAIDA01); 
*
0D1E:  BCF    F95.1
0D20:  BSF    F8C.1
....................   else if(temperatura > temperatura_maxima) 
0D22:  BRA    0D54
0D24:  CLRF   20
0D26:  MOVFF  0C,1F
0D2A:  RCALL  07FC
0D2C:  MOVFF  03,1E
0D30:  MOVFF  02,1D
0D34:  MOVFF  01,1C
0D38:  MOVFF  00,1B
0D3C:  MOVFF  11,22
0D40:  MOVFF  10,21
0D44:  MOVFF  0F,20
0D48:  MOVFF  0E,1F
0D4C:  RCALL  0924
0D4E:  BNC   0D54
....................     output_low(SAIDA01); 
0D50:  BCF    F95.1
0D52:  BCF    F8C.1
.................... } 
0D54:  GOTO   178A (RETURN)
....................  
.................... read_temperature() { 
.................... long int adc; 
.................... float formula; 
....................  
....................   adc = read_adc(); 
*
0C06:  BSF    FC2.2
0C08:  BTFSC  FC2.2
0C0A:  BRA    0C08
0C0C:  MOVFF  FC3,15
0C10:  MOVFF  FC4,16
....................   formula = ((adc - 220) * 0.0007 ); 
0C14:  MOVLW  DC
0C16:  SUBWF  15,W
0C18:  MOVWF  1B
0C1A:  MOVLW  00
0C1C:  SUBWFB 16,W
0C1E:  MOVWF  1C
0C20:  MOVWF  20
0C22:  MOVFF  1B,1F
0C26:  RCALL  07FC
0C28:  MOVFF  03,26
0C2C:  MOVFF  02,25
0C30:  MOVFF  01,24
0C34:  MOVFF  00,23
0C38:  MOVLW  34
0C3A:  MOVWF  2A
0C3C:  MOVLW  80
0C3E:  MOVWF  29
0C40:  MOVLW  37
0C42:  MOVWF  28
0C44:  MOVLW  74
0C46:  MOVWF  27
0C48:  RCALL  0832
0C4A:  MOVFF  03,1A
0C4E:  MOVFF  02,19
0C52:  MOVFF  01,18
0C56:  MOVFF  00,17
....................   if(formula < 0) 
0C5A:  MOVFF  1A,1E
0C5E:  MOVFF  19,1D
0C62:  MOVFF  18,1C
0C66:  MOVFF  17,1B
0C6A:  CLRF   22
0C6C:  CLRF   21
0C6E:  CLRF   20
0C70:  CLRF   1F
0C72:  RCALL  0924
0C74:  BNC   0C7E
....................    formula = 0; 
0C76:  CLRF   1A
0C78:  CLRF   19
0C7A:  CLRF   18
0C7C:  CLRF   17
....................   temperatura = adc * (0.049 + formula); 
0C7E:  BCF    FD8.1
0C80:  MOVLW  39
0C82:  MOVWF  1E
0C84:  MOVLW  B4
0C86:  MOVWF  1D
0C88:  MOVLW  48
0C8A:  MOVWF  1C
0C8C:  MOVLW  7A
0C8E:  MOVWF  1B
0C90:  MOVFF  1A,22
0C94:  MOVFF  19,21
0C98:  MOVFF  18,20
0C9C:  MOVFF  17,1F
0CA0:  BRA    099A
0CA2:  MOVFF  00,1B
0CA6:  MOVFF  01,1C
0CAA:  MOVFF  02,1D
0CAE:  MOVFF  03,1E
0CB2:  MOVFF  16,20
0CB6:  MOVFF  15,1F
0CBA:  RCALL  07FC
0CBC:  MOVFF  03,26
0CC0:  MOVFF  02,25
0CC4:  MOVFF  01,24
0CC8:  MOVFF  00,23
0CCC:  MOVFF  1E,2A
0CD0:  MOVFF  1D,29
0CD4:  MOVFF  1C,28
0CD8:  MOVFF  1B,27
0CDC:  RCALL  0832
0CDE:  MOVFF  03,11
0CE2:  MOVFF  02,10
0CE6:  MOVFF  01,0F
0CEA:  MOVFF  00,0E
....................  
....................   //envia o cursor do LCD para a posicao 0,0 
....................   //display(0,0xA0); 
.................... //imprime na tela a temperatura 
....................   //printf(mostra,"ADC: %ld    ",adc); 
....................   //envia o cursor do LCD para a posicao 0,0 
....................   //display(0,0xD0); 
.................... //imprime na tela a temperatura 
....................   //printf(mostra,"form: %f    ",formula); 
....................    
.................... } 
0CEE:  RETLW  00
....................  
....................  
.................... show_temperature(){ 
.................... //envia o cursor do LCD para a posicao 0,0 
....................   display(0,0x80); 
*
0FA0:  CLRF   24
0FA2:  MOVLW  80
0FA4:  MOVWF  25
0FA6:  CALL   04A6
.................... //imprime na tela a temperatura 
....................   printf(mostra,"Temperatura: %.0lfC    ",temperatura); 
0FAA:  CLRF   15
0FAC:  MOVF   15,W
0FAE:  CALL   0004
0FB2:  INCF   15,F
0FB4:  MOVWF  00
0FB6:  MOVWF  23
0FB8:  RCALL  0D58
0FBA:  MOVLW  0D
0FBC:  SUBWF  15,W
0FBE:  BNZ   0FAC
0FC0:  MOVLW  89
0FC2:  MOVWF  FE9
0FC4:  MOVFF  11,19
0FC8:  MOVFF  10,18
0FCC:  MOVFF  0F,17
0FD0:  MOVFF  0E,16
0FD4:  CLRF   1A
0FD6:  BRA    0E20
0FD8:  MOVLW  12
0FDA:  MOVWF  16
0FDC:  MOVF   16,W
0FDE:  CALL   0004
0FE2:  INCF   16,F
0FE4:  MOVWF  00
0FE6:  MOVWF  23
0FE8:  RCALL  0D58
0FEA:  MOVLW  17
0FEC:  SUBWF  16,W
0FEE:  BNZ   0FDC
.................... } 
0FF0:  GOTO   178C (RETURN)
....................  
.................... update_clock(){ 
....................  
....................   ds1307_get_date(day,month,yr,dow);  
....................   ds1307_get_time(hrs,min,sec);  
....................  
....................   sec = ds1307_read_byte(0); 
*
07E6:  CLRF   15
07E8:  BRA    05CA
07EA:  MOVFF  01,05
....................   sec = bcd2bin(sec); 
07EE:  MOVFF  05,1B
07F2:  RCALL  02E4
07F4:  MOVFF  01,05
....................  
.................... } 
07F8:  GOTO   1782 (RETURN)
....................  
.................... show_clock(){ 
....................  
.................... //envia o cursor do LCD para a posicao 1,0 
....................   display(0,0xC0); 
*
10E4:  CLRF   24
10E6:  MOVLW  C0
10E8:  MOVWF  25
10EA:  CALL   04A6
....................  
.................... //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................   printf(mostra,"Hora: \%02d:\%02d:\%02d     ", hrs,min,sec);  
10EE:  CLRF   15
10F0:  MOVF   15,W
10F2:  CALL   002C
10F6:  INCF   15,F
10F8:  MOVWF  00
10FA:  MOVWF  23
10FC:  RCALL  0D58
10FE:  MOVLW  06
1100:  SUBWF  15,W
1102:  BNZ   10F0
1104:  MOVFF  07,16
1108:  MOVLW  01
110A:  MOVWF  17
110C:  RCALL  101C
110E:  MOVLW  3A
1110:  MOVWF  23
1112:  RCALL  0D58
1114:  MOVFF  06,16
1118:  MOVLW  01
111A:  MOVWF  17
111C:  RCALL  101C
111E:  MOVLW  3A
1120:  MOVWF  23
1122:  RCALL  0D58
1124:  MOVFF  05,16
1128:  MOVLW  01
112A:  MOVWF  17
112C:  RCALL  101C
112E:  MOVLW  14
1130:  MOVWF  16
1132:  MOVF   16,W
1134:  CALL   002C
1138:  INCF   16,F
113A:  MOVWF  00
113C:  MOVWF  23
113E:  RCALL  0D58
1140:  MOVLW  19
1142:  SUBWF  16,W
1144:  BNZ   1132
.................... } 
1146:  GOTO   178E (RETURN)
....................  
....................  
.................... configure_time() { 
....................   static int state = 0; 
....................  
....................   //envia o cursor do LCD para a posicao 1,0 
....................   display(0,0x80); 
*
12FA:  CLRF   24
12FC:  MOVLW  80
12FE:  MOVWF  25
1300:  CALL   04A6
....................   //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................   printf(mostra,"Config Relogio    "); 
1304:  CLRF   15
1306:  MOVF   15,W
1308:  CALL   0056
130C:  INCF   15,F
130E:  MOVWF  00
1310:  MOVWF  23
1312:  RCALL  0D58
1314:  MOVLW  12
1316:  SUBWF  15,W
1318:  BNZ   1306
....................  
....................   //envia o cursor do LCD para a posicao 1,0 
....................   display(0,0xC0); 
131A:  CLRF   24
131C:  MOVLW  C0
131E:  MOVWF  25
1320:  CALL   04A6
....................   //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................   printf(mostra,"H\%02d:\%02d:\%02d D\%02d/\%02d/\%02d    ", hrs,min,sec,day,month,yr);  
1324:  MOVLW  48
1326:  MOVWF  23
1328:  RCALL  0D58
132A:  MOVFF  07,16
132E:  MOVLW  01
1330:  MOVWF  17
1332:  RCALL  101C
1334:  MOVLW  3A
1336:  MOVWF  23
1338:  RCALL  0D58
133A:  MOVFF  06,16
133E:  MOVLW  01
1340:  MOVWF  17
1342:  RCALL  101C
1344:  MOVLW  3A
1346:  MOVWF  23
1348:  RCALL  0D58
134A:  MOVFF  05,16
134E:  MOVLW  01
1350:  MOVWF  17
1352:  RCALL  101C
1354:  MOVLW  20
1356:  MOVWF  23
1358:  RCALL  0D58
135A:  MOVLW  44
135C:  MOVWF  23
135E:  RCALL  0D58
1360:  MOVFF  08,16
1364:  MOVLW  01
1366:  MOVWF  17
1368:  RCALL  101C
136A:  MOVLW  2F
136C:  MOVWF  23
136E:  RCALL  0D58
1370:  MOVFF  09,16
1374:  MOVLW  01
1376:  MOVWF  17
1378:  RCALL  101C
137A:  MOVLW  2F
137C:  MOVWF  23
137E:  RCALL  0D58
1380:  MOVFF  0A,16
1384:  MOVLW  01
1386:  MOVWF  17
1388:  RCALL  101C
138A:  MOVLW  1F
138C:  MOVWF  15
138E:  MOVF   15,W
1390:  CALL   007A
1394:  INCF   15,F
1396:  MOVWF  00
1398:  MOVWF  23
139A:  RCALL  0D58
139C:  MOVLW  23
139E:  SUBWF  15,W
13A0:  BNZ   138E
....................  
....................  
....................   switch(state){ 
13A2:  MOVF   13,W
13A4:  ADDLW  F8
13A6:  BTFSC  FD8.0
13A8:  BRA    16EA
13AA:  ADDLW  08
13AC:  GOTO   16EE
....................     case 0: //menu superior 
....................       if(TECLA_SET) 
13B0:  BSF    F95.0
13B2:  BTFSC  F83.0
13B4:  BRA    13BC
....................         state = 1; 
13B6:  MOVLW  01
13B8:  MOVWF  13
....................       else if(TECLA_MAIS) 
13BA:  BRA    13D0
13BC:  BSF    F95.3
13BE:  BTFSC  F83.3
13C0:  BRA    13C6
....................         tela = 0; 
13C2:  CLRF   0D
....................       else if(TECLA_MENOS) 
13C4:  BRA    13D0
13C6:  BSF    F95.2
13C8:  BTFSC  F83.2
13CA:  BRA    13D0
....................         tela = 1; 
13CC:  MOVLW  01
13CE:  MOVWF  0D
....................       break; 
13D0:  BRA    16EA
....................  
....................     case 1: //hora 
....................       display(0,0xC0); 
13D2:  CLRF   24
13D4:  MOVLW  C0
13D6:  MOVWF  25
13D8:  CALL   04A6
....................       //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................       printf(mostra,"Horas:\%02d            ", hrs); 
13DC:  CLRF   15
13DE:  MOVF   15,W
13E0:  CALL   00AE
13E4:  INCF   15,F
13E6:  MOVWF  00
13E8:  MOVWF  23
13EA:  RCALL  0D58
13EC:  MOVLW  06
13EE:  SUBWF  15,W
13F0:  BNZ   13DE
13F2:  MOVFF  07,16
13F6:  MOVLW  01
13F8:  MOVWF  17
13FA:  RCALL  101C
13FC:  MOVLW  0A
13FE:  MOVWF  16
1400:  MOVF   16,W
1402:  CALL   00AE
1406:  INCF   16,F
1408:  MOVWF  00
140A:  MOVWF  23
140C:  RCALL  0D58
140E:  MOVLW  16
1410:  SUBWF  16,W
1412:  BNZ   1400
....................       if(TECLA_SET) 
1414:  BSF    F95.0
1416:  BTFSC  F83.0
1418:  BRA    1420
....................         state = 2; 
141A:  MOVLW  02
141C:  MOVWF  13
....................       else if(TECLA_MAIS){ 
141E:  BRA    1444
1420:  BSF    F95.3
1422:  BTFSC  F83.3
1424:  BRA    1432
....................         hrs++; 
1426:  INCF   07,F
....................         if(hrs > 23) 
1428:  MOVF   07,W
142A:  SUBLW  17
142C:  BC    1430
....................           hrs = 0; 
142E:  CLRF   07
....................       } 
....................       else if(TECLA_MENOS){ 
1430:  BRA    1444
1432:  BSF    F95.2
1434:  BTFSC  F83.2
1436:  BRA    1444
....................         hrs--; 
1438:  DECF   07,F
....................         if(hrs == -1) 
143A:  MOVF   07,W
143C:  SUBLW  FF
143E:  BNZ   1444
....................           hrs = 23; 
1440:  MOVLW  17
1442:  MOVWF  07
....................       } 
....................       break; 
1444:  BRA    16EA
....................     case 2: //minuto 
....................       display(0,0xC0); 
1446:  CLRF   24
1448:  MOVLW  C0
144A:  MOVWF  25
144C:  CALL   04A6
....................       //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................       printf(mostra,"Minutos:\%02d         ", min); 
1450:  CLRF   15
1452:  MOVF   15,W
1454:  CALL   00D6
1458:  INCF   15,F
145A:  MOVWF  00
145C:  MOVWF  23
145E:  RCALL  0D58
1460:  MOVLW  08
1462:  SUBWF  15,W
1464:  BNZ   1452
1466:  MOVFF  06,16
146A:  MOVLW  01
146C:  MOVWF  17
146E:  RCALL  101C
1470:  MOVLW  0C
1472:  MOVWF  16
1474:  MOVF   16,W
1476:  CALL   00D6
147A:  INCF   16,F
147C:  MOVWF  00
147E:  MOVWF  23
1480:  RCALL  0D58
1482:  MOVLW  15
1484:  SUBWF  16,W
1486:  BNZ   1474
....................       if(TECLA_SET) 
1488:  BSF    F95.0
148A:  BTFSC  F83.0
148C:  BRA    1494
....................         state = 3; 
148E:  MOVLW  03
1490:  MOVWF  13
....................       else if(TECLA_MAIS){ 
1492:  BRA    14B8
1494:  BSF    F95.3
1496:  BTFSC  F83.3
1498:  BRA    14A6
....................         min++; 
149A:  INCF   06,F
....................         if(min > 59) 
149C:  MOVF   06,W
149E:  SUBLW  3B
14A0:  BC    14A4
....................           min = 0; 
14A2:  CLRF   06
....................       } 
....................       else if(TECLA_MENOS){ 
14A4:  BRA    14B8
14A6:  BSF    F95.2
14A8:  BTFSC  F83.2
14AA:  BRA    14B8
....................         min--; 
14AC:  DECF   06,F
....................         if(min == -1) 
14AE:  MOVF   06,W
14B0:  SUBLW  FF
14B2:  BNZ   14B8
....................           min = 59; 
14B4:  MOVLW  3B
14B6:  MOVWF  06
....................       } 
....................       break; 
14B8:  BRA    16EA
....................     case 3: //segundo 
....................       display(0,0xC0); 
14BA:  CLRF   24
14BC:  MOVLW  C0
14BE:  MOVWF  25
14C0:  CALL   04A6
....................       //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................       printf(mostra,"Segundos:\%02d            ", sec); 
14C4:  CLRF   15
14C6:  MOVF   15,W
14C8:  CALL   00FC
14CC:  INCF   15,F
14CE:  MOVWF  00
14D0:  MOVWF  23
14D2:  RCALL  0D58
14D4:  MOVLW  09
14D6:  SUBWF  15,W
14D8:  BNZ   14C6
14DA:  MOVFF  05,16
14DE:  MOVLW  01
14E0:  MOVWF  17
14E2:  RCALL  101C
14E4:  MOVLW  0D
14E6:  MOVWF  16
14E8:  MOVF   16,W
14EA:  CALL   00FC
14EE:  INCF   16,F
14F0:  MOVWF  00
14F2:  MOVWF  23
14F4:  RCALL  0D58
14F6:  MOVLW  19
14F8:  SUBWF  16,W
14FA:  BNZ   14E8
....................       if(TECLA_SET) 
14FC:  BSF    F95.0
14FE:  BTFSC  F83.0
1500:  BRA    1508
....................         state = 4; 
1502:  MOVLW  04
1504:  MOVWF  13
....................       else if(TECLA_MAIS){ 
1506:  BRA    152C
1508:  BSF    F95.3
150A:  BTFSC  F83.3
150C:  BRA    151A
....................         sec++; 
150E:  INCF   05,F
....................         if(sec > 59) 
1510:  MOVF   05,W
1512:  SUBLW  3B
1514:  BC    1518
....................           sec = 0; 
1516:  CLRF   05
....................       } 
....................       else if(TECLA_MENOS){ 
1518:  BRA    152C
151A:  BSF    F95.2
151C:  BTFSC  F83.2
151E:  BRA    152C
....................         sec--; 
1520:  DECF   05,F
....................         if(sec == -1) 
1522:  MOVF   05,W
1524:  SUBLW  FF
1526:  BNZ   152C
....................           sec = 59; 
1528:  MOVLW  3B
152A:  MOVWF  05
....................       } 
....................       break; 
152C:  BRA    16EA
....................     case 4: //dia 
....................       display(0,0xC0); 
152E:  CLRF   24
1530:  MOVLW  C0
1532:  MOVWF  25
1534:  CALL   04A6
....................       //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................       printf(mostra,"Dia:\%02d            ", day); 
1538:  CLRF   15
153A:  MOVF   15,W
153C:  CALL   0126
1540:  INCF   15,F
1542:  MOVWF  00
1544:  MOVWF  23
1546:  RCALL  0D58
1548:  MOVLW  04
154A:  SUBWF  15,W
154C:  BNZ   153A
154E:  MOVFF  08,16
1552:  MOVLW  01
1554:  MOVWF  17
1556:  RCALL  101C
1558:  MOVLW  08
155A:  MOVWF  16
155C:  MOVF   16,W
155E:  CALL   0126
1562:  INCF   16,F
1564:  MOVWF  00
1566:  MOVWF  23
1568:  CALL   0D58
156C:  MOVLW  14
156E:  SUBWF  16,W
1570:  BNZ   155C
....................       if(TECLA_SET) 
1572:  BSF    F95.0
1574:  BTFSC  F83.0
1576:  BRA    157E
....................         state = 5; 
1578:  MOVLW  05
157A:  MOVWF  13
....................       else if(TECLA_MAIS){ 
157C:  BRA    15A2
157E:  BSF    F95.3
1580:  BTFSC  F83.3
1582:  BRA    1592
....................         day++; 
1584:  INCF   08,F
....................         if(day > 31) 
1586:  MOVF   08,W
1588:  SUBLW  1F
158A:  BC    1590
....................           day = 1; 
158C:  MOVLW  01
158E:  MOVWF  08
....................       } 
....................       else if(TECLA_MENOS){ 
1590:  BRA    15A2
1592:  BSF    F95.2
1594:  BTFSC  F83.2
1596:  BRA    15A2
....................         day--; 
1598:  DECF   08,F
....................         if(day < 1) 
159A:  MOVF   08,F
159C:  BNZ   15A2
....................           day = 31; 
159E:  MOVLW  1F
15A0:  MOVWF  08
....................       } 
....................       break; 
15A2:  BRA    16EA
....................     case 5: //mes 
....................       display(0,0xC0); 
15A4:  CLRF   24
15A6:  MOVLW  C0
15A8:  MOVWF  25
15AA:  CALL   04A6
....................       //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................       printf(mostra,"Mes:\%02d            ", month); 
15AE:  CLRF   15
15B0:  MOVF   15,W
15B2:  CALL   014C
15B6:  INCF   15,F
15B8:  MOVWF  00
15BA:  MOVWF  23
15BC:  CALL   0D58
15C0:  MOVLW  04
15C2:  SUBWF  15,W
15C4:  BNZ   15B0
15C6:  MOVFF  09,16
15CA:  MOVLW  01
15CC:  MOVWF  17
15CE:  RCALL  101C
15D0:  MOVLW  08
15D2:  MOVWF  16
15D4:  MOVF   16,W
15D6:  CALL   014C
15DA:  INCF   16,F
15DC:  MOVWF  00
15DE:  MOVWF  23
15E0:  CALL   0D58
15E4:  MOVLW  14
15E6:  SUBWF  16,W
15E8:  BNZ   15D4
....................       if(TECLA_SET) 
15EA:  BSF    F95.0
15EC:  BTFSC  F83.0
15EE:  BRA    15F6
....................         state = 6; 
15F0:  MOVLW  06
15F2:  MOVWF  13
....................       else if(TECLA_MAIS){ 
15F4:  BRA    161A
15F6:  BSF    F95.3
15F8:  BTFSC  F83.3
15FA:  BRA    160A
....................         month++; 
15FC:  INCF   09,F
....................         if(month > 12) 
15FE:  MOVF   09,W
1600:  SUBLW  0C
1602:  BC    1608
....................           month = 1; 
1604:  MOVLW  01
1606:  MOVWF  09
....................       } 
....................       else if(TECLA_MENOS){ 
1608:  BRA    161A
160A:  BSF    F95.2
160C:  BTFSC  F83.2
160E:  BRA    161A
....................         month--; 
1610:  DECF   09,F
....................         if(month < 1) 
1612:  MOVF   09,F
1614:  BNZ   161A
....................           month = 12; 
1616:  MOVLW  0C
1618:  MOVWF  09
....................       } 
....................       break; 
161A:  BRA    16EA
....................     case 6: //ano 
....................       display(0,0xC0); 
161C:  CLRF   24
161E:  MOVLW  C0
1620:  MOVWF  25
1622:  CALL   04A6
....................       //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................       printf(mostra,"Ano:\%02d            ", yr); 
1626:  CLRF   15
1628:  MOVF   15,W
162A:  CALL   0172
162E:  INCF   15,F
1630:  MOVWF  00
1632:  MOVWF  23
1634:  CALL   0D58
1638:  MOVLW  04
163A:  SUBWF  15,W
163C:  BNZ   1628
163E:  MOVFF  0A,16
1642:  MOVLW  01
1644:  MOVWF  17
1646:  RCALL  101C
1648:  MOVLW  08
164A:  MOVWF  16
164C:  MOVF   16,W
164E:  CALL   0172
1652:  INCF   16,F
1654:  MOVWF  00
1656:  MOVWF  23
1658:  CALL   0D58
165C:  MOVLW  14
165E:  SUBWF  16,W
1660:  BNZ   164C
....................       if(TECLA_SET) 
1662:  BSF    F95.0
1664:  BTFSC  F83.0
1666:  BRA    166E
....................         state = 7; 
1668:  MOVLW  07
166A:  MOVWF  13
....................       else if(TECLA_MAIS){ 
166C:  BRA    1690
166E:  BSF    F95.3
1670:  BTFSC  F83.3
1672:  BRA    1680
....................         yr++; 
1674:  INCF   0A,F
....................         if(yr > 30) 
1676:  MOVF   0A,W
1678:  SUBLW  1E
167A:  BC    167E
....................           yr = 0; 
167C:  CLRF   0A
....................       } 
....................       else if(TECLA_MENOS){ 
167E:  BRA    1690
1680:  BSF    F95.2
1682:  BTFSC  F83.2
1684:  BRA    1690
....................         yr--; 
1686:  DECF   0A,F
....................         if(yr < 1) 
1688:  MOVF   0A,F
168A:  BNZ   1690
....................           yr = 30; 
168C:  MOVLW  1E
168E:  MOVWF  0A
....................       } 
....................       break; 
1690:  BRA    16EA
....................     case 7: //mes 
....................  
....................       //envia o cursor do LCD para a posicao 1,0 
....................       display(0,0xC0); 
1692:  CLRF   24
1694:  MOVLW  C0
1696:  MOVWF  25
1698:  CALL   04A6
....................       //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................       printf(mostra,"Salvar? - NAO, + SIM");  
169C:  CLRF   15
169E:  MOVF   15,W
16A0:  CALL   0198
16A4:  INCF   15,F
16A6:  MOVWF  00
16A8:  MOVWF  23
16AA:  CALL   0D58
16AE:  MOVLW  14
16B0:  SUBWF  15,W
16B2:  BNZ   169E
....................       if(TECLA_MAIS){ 
16B4:  BSF    F95.3
16B6:  BTFSC  F83.3
16B8:  BRA    16DE
....................         ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); 
16BA:  MOVFF  08,15
16BE:  MOVFF  09,16
16C2:  MOVFF  0A,17
16C6:  MOVFF  0B,18
16CA:  MOVFF  07,19
16CE:  MOVFF  06,1A
16D2:  MOVFF  05,1B
16D6:  BRA    120A
....................         tela = 0; 
16D8:  CLRF   0D
....................         state = 0; 
16DA:  CLRF   13
....................       } 
....................       else if(TECLA_MENOS){ 
16DC:  BRA    16E8
16DE:  BSF    F95.2
16E0:  BTFSC  F83.2
16E2:  BRA    16E8
....................         state = 0; 
16E4:  CLRF   13
....................         tela = 0; 
16E6:  CLRF   0D
....................       } 
....................       break; 
16E8:  BRA    16EA
....................     } 
....................  
.................... } 
16EA:  GOTO   17BA (RETURN)
....................  
.................... configure_temperature() { 
....................   static int state; 
....................  
....................   //envia o cursor do LCD para a posicao 1,0 
....................   display(0,0x80); 
*
114A:  CLRF   24
114C:  MOVLW  80
114E:  MOVWF  25
1150:  CALL   04A6
....................   //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................   printf(mostra,"Config Temperatura    "); 
1154:  CLRF   15
1156:  MOVF   15,W
1158:  CALL   01BE
115C:  INCF   15,F
115E:  MOVWF  00
1160:  MOVWF  23
1162:  RCALL  0D58
1164:  MOVLW  16
1166:  SUBWF  15,W
1168:  BNZ   1156
....................  
....................   //envia o cursor do LCD para a posicao 1,0 
....................   display(0,0xC0); 
116A:  CLRF   24
116C:  MOVLW  C0
116E:  MOVWF  25
1170:  CALL   04A6
....................   //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................   printf(mostra,"Temp Max: \%02d             ", temperatura_maxima);  
1174:  CLRF   15
1176:  MOVF   15,W
1178:  CALL   01E6
117C:  INCF   15,F
117E:  MOVWF  00
1180:  MOVWF  23
1182:  RCALL  0D58
1184:  MOVLW  0A
1186:  SUBWF  15,W
1188:  BNZ   1176
118A:  MOVFF  0C,16
118E:  MOVLW  01
1190:  MOVWF  17
1192:  RCALL  101C
1194:  MOVLW  0E
1196:  MOVWF  16
1198:  MOVF   16,W
119A:  CALL   01E6
119E:  INCF   16,F
11A0:  MOVWF  00
11A2:  MOVWF  23
11A4:  RCALL  0D58
11A6:  MOVLW  1B
11A8:  SUBWF  16,W
11AA:  BNZ   1198
....................  
....................   switch(state){ 
11AC:  MOVF   14,W
11AE:  BZ    11B6
11B0:  XORLW  01
11B2:  BZ    11D8
11B4:  BRA    1206
....................   case 0: //menu superior 
....................     if(TECLA_SET) 
11B6:  BSF    F95.0
11B8:  BTFSC  F83.0
11BA:  BRA    11C2
....................       state = 1; 
11BC:  MOVLW  01
11BE:  MOVWF  14
....................     else if(TECLA_MAIS) 
11C0:  BRA    11D6
11C2:  BSF    F95.3
11C4:  BTFSC  F83.3
11C6:  BRA    11CE
....................       tela = 2; 
11C8:  MOVLW  02
11CA:  MOVWF  0D
....................     else if(TECLA_MENOS) 
11CC:  BRA    11D6
11CE:  BSF    F95.2
11D0:  BTFSC  F83.2
11D2:  BRA    11D6
....................       tela = 0; 
11D4:  CLRF   0D
....................     break; 
11D6:  BRA    1206
....................  
....................   case 1: //temperatura maxima 
....................     if(TECLA_SET) 
11D8:  BSF    F95.0
11DA:  BTFSC  F83.0
11DC:  BRA    11E2
....................       state = 0; 
11DE:  CLRF   14
....................     else if(TECLA_MAIS){ 
11E0:  BRA    1204
11E2:  BSF    F95.3
11E4:  BTFSC  F83.3
11E6:  BRA    11F4
....................       temperatura_maxima++; 
11E8:  INCF   0C,F
....................       if(temperatura_maxima > 100) 
11EA:  MOVF   0C,W
11EC:  SUBLW  64
11EE:  BC    11F2
....................         temperatura_maxima = 0; 
11F0:  CLRF   0C
....................     } 
....................     else if(TECLA_MENOS){ 
11F2:  BRA    1204
11F4:  BSF    F95.2
11F6:  BTFSC  F83.2
11F8:  BRA    1204
....................       temperatura_maxima--; 
11FA:  DECF   0C,F
....................       if(temperatura_maxima < 1) 
11FC:  MOVF   0C,F
11FE:  BNZ   1204
....................         temperatura_maxima = 100; 
1200:  MOVLW  64
1202:  MOVWF  0C
....................     } 
....................     break; 
1204:  BRA    1206
....................   } 
.................... } 
1206:  GOTO   17BA (RETURN)

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
