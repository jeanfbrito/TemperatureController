CCS PCH C Compiler, Version 4.057, 8241               19-nov-12 20:29

               Filename: C:\Users\Jean\Documents\GitHub\TemperatureController\main.lst

               ROM used: 3500 bytes (11%)
                         Largest free fragment is 29268
               RAM used: 24 (2%) at main() level
                         45 (3%) worst case
               Stack:    3 locations

*
0000:  GOTO   0B36
.................... #include <18f452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #device ADC=10 
.................... #use delay(clock=20000000) 
*
0374:  CLRF   FEA
0376:  MOVLW  14
0378:  MOVWF  FE9
037A:  MOVF   FEF,W
037C:  BZ    0398
037E:  MOVLW  06
0380:  MOVWF  01
0382:  CLRF   00
0384:  DECFSZ 00,F
0386:  BRA    0384
0388:  DECFSZ 01,F
038A:  BRA    0382
038C:  MOVLW  7B
038E:  MOVWF  00
0390:  DECFSZ 00,F
0392:  BRA    0390
0394:  DECFSZ FEF,F
0396:  BRA    037E
0398:  RETLW  00
039A:  MOVLW  03
039C:  SUBWF  13,F
039E:  BNC   03B2
03A0:  CLRF   FEA
03A2:  MOVLW  13
03A4:  MOVWF  FE9
03A6:  MOVF   FEF,W
03A8:  BZ    03B2
03AA:  BRA    03AE
03AC:  BRA    03AE
03AE:  DECFSZ FEF,F
03B0:  BRA    03AC
03B2:  RETLW  00
.................... #fuses HS,NOWDT,PUT 
.................... #include <lcd_generico.c> 
.................... /* 
....................  
.................... Função para utilização do display LCD para qualquer tamanho 
....................  
....................    inic_display();                        função para configurar e inicializar o display 
....................    display(char tipo,char dado);          função para enviar um comando ou um dado para o display 
....................    mostra(char dado);                     funçao para enviar um dado para o display 
....................  
....................    Configuração dos pinos do microcontrolador 
....................  
....................    RB0 = enable display 
....................    RB1 = RS 
....................    RB2 = RW 
....................    RB3 = 
....................    RB4 = DB4 
....................    RB5 = DB5 
....................    RB6 = DB6 
....................    RB7 = DB7 
....................  
....................    Primeira linha = 0x80 
....................    Segunda  linha = 0xC0 
....................  
....................  
.................... Aprimorado por Cleber Toss Hoffmann 
.................... cleber.toss.hoffmann@gmail.com 
....................  
.................... */ 
.................... // 
.................... #byte PORTB=0xF81 
.................... #byte TRISB=0xF93 
....................  
.................... //Constantes 
.................... #define set_bit0 0x01 
.................... #define set_bit1 0x02 
.................... #define set_bit2 0x04 
....................  
.................... #define clear_bit0 0xfe 
.................... #define clear_bit1 0xfd 
.................... #define clear_bit2 0xfb 
....................  
.................... void inic_display(); 
....................  
.................... #separate 
.................... void display(char tipo,char dado); 
....................  
.................... #separate 
.................... void mostra(char dado); 
....................  
.................... void inic_display() 
.................... { 
....................  TRISB =0x00; 
*
0430:  CLRF   F93
....................  delay_ms(50); 
0432:  MOVLW  32
0434:  MOVWF  14
0436:  RCALL  0374
....................  
....................  PORTB  = 0x30; 
0438:  MOVLW  30
043A:  MOVWF  F81
....................  PORTB |= set_bit0; 
043C:  BSF    F81.0
....................  delay_us(5); 
043E:  MOVLW  08
0440:  MOVWF  00
0442:  DECFSZ 00,F
0444:  BRA    0442
....................  PORTB &= clear_bit0; 
0446:  BCF    F81.0
....................  delay_ms(25); 
0448:  MOVLW  19
044A:  MOVWF  14
044C:  RCALL  0374
....................  
....................  PORTB = 0x30; 
044E:  MOVLW  30
0450:  MOVWF  F81
....................  PORTB |= set_bit0; 
0452:  BSF    F81.0
....................  delay_us(5); 
0454:  MOVLW  08
0456:  MOVWF  00
0458:  DECFSZ 00,F
045A:  BRA    0458
....................  PORTB &= clear_bit0; 
045C:  BCF    F81.0
....................  delay_ms(25); 
045E:  MOVLW  19
0460:  MOVWF  14
0462:  RCALL  0374
....................  
....................  PORTB = 0x30; 
0464:  MOVLW  30
0466:  MOVWF  F81
....................  PORTB |= set_bit0; 
0468:  BSF    F81.0
....................  delay_us(5); 
046A:  MOVLW  08
046C:  MOVWF  00
046E:  DECFSZ 00,F
0470:  BRA    046E
....................  PORTB &= clear_bit0; 
0472:  BCF    F81.0
....................  delay_ms(25); 
0474:  MOVLW  19
0476:  MOVWF  14
0478:  RCALL  0374
....................  
....................  PORTB = 0x30; 
047A:  MOVLW  30
047C:  MOVWF  F81
....................  PORTB |= set_bit0; 
047E:  BSF    F81.0
....................  delay_us(5); 
0480:  MOVLW  08
0482:  MOVWF  00
0484:  DECFSZ 00,F
0486:  BRA    0484
....................  PORTB &= clear_bit0; 
0488:  BCF    F81.0
....................  
....................  delay_us(200); 
048A:  MOVLW  C8
048C:  MOVWF  13
048E:  RCALL  039A
....................  PORTB = 0x20; 
0490:  MOVLW  20
0492:  MOVWF  F81
....................  PORTB |= set_bit0; 
0494:  BSF    F81.0
....................  delay_us(5); 
0496:  MOVLW  08
0498:  MOVWF  00
049A:  DECFSZ 00,F
049C:  BRA    049A
....................  PORTB &= clear_bit0; 
049E:  BCF    F81.0
....................  
....................  delay_us(200); 
04A0:  MOVLW  C8
04A2:  MOVWF  13
04A4:  RCALL  039A
....................  display(0,0x28); 
04A6:  CLRF   22
04A8:  MOVLW  28
04AA:  MOVWF  23
04AC:  RCALL  03B4
....................  display(0,0x08); 
04AE:  CLRF   22
04B0:  MOVLW  08
04B2:  MOVWF  23
04B4:  RCALL  03B4
....................  display(0,0x01); 
04B6:  CLRF   22
04B8:  MOVLW  01
04BA:  MOVWF  23
04BC:  RCALL  03B4
....................  delay_ms(5); 
04BE:  MOVLW  05
04C0:  MOVWF  14
04C2:  RCALL  0374
....................  display(0,0x06); 
04C4:  CLRF   22
04C6:  MOVLW  06
04C8:  MOVWF  23
04CA:  RCALL  03B4
....................  display(0,0x0c); 
04CC:  CLRF   22
04CE:  MOVLW  0C
04D0:  MOVWF  23
04D2:  RCALL  03B4
....................  
.................... } 
04D4:  GOTO   0B9C (RETURN)
....................  
....................  
.................... /* display 
....................    Envia um dado para o display. 
....................    Se tipo=0, é um comando (RS=0) 
....................    Se tipo=1, é um dado (RS=1) 
.................... */ 
.................... #separate 
.................... void display(char tipo,char dado) 
.................... { 
....................  char temp; 
....................  if(tipo == true) 
*
03B4:  DECFSZ 22,W
03B6:  BRA    03F8
....................     { 
....................      temp=(dado & 0xf0) | set_bit1; 
03B8:  MOVF   23,W
03BA:  ANDLW  F0
03BC:  IORLW  02
03BE:  MOVWF  24
....................      PORTB = temp; 
03C0:  MOVFF  24,F81
....................      PORTB |= set_bit0; 
03C4:  BSF    F81.0
....................      delay_us(5); 
03C6:  MOVLW  08
03C8:  MOVWF  00
03CA:  DECFSZ 00,F
03CC:  BRA    03CA
....................      PORTB &= clear_bit0; 
03CE:  BCF    F81.0
.................... //   delay_us(50); 
....................      temp=(dado << 4) | set_bit1; 
03D0:  SWAPF  23,W
03D2:  MOVWF  00
03D4:  MOVLW  F0
03D6:  ANDWF  00,F
03D8:  MOVF   00,W
03DA:  IORLW  02
03DC:  MOVWF  24
....................      PORTB = temp; 
03DE:  MOVFF  24,F81
....................      PORTB |= set_bit0; 
03E2:  BSF    F81.0
....................      delay_us(5); 
03E4:  MOVLW  08
03E6:  MOVWF  00
03E8:  DECFSZ 00,F
03EA:  BRA    03E8
....................      PORTB &= clear_bit0; 
03EC:  BCF    F81.0
....................      delay_us(50); 
03EE:  MOVLW  53
03F0:  MOVWF  00
03F2:  DECFSZ 00,F
03F4:  BRA    03F2
....................  
....................     } 
....................  else 
03F6:  BRA    042E
....................     { 
....................      temp=(dado & 0xf0); 
03F8:  MOVF   23,W
03FA:  ANDLW  F0
03FC:  MOVWF  24
....................      PORTB = temp; 
03FE:  MOVFF  24,F81
....................      PORTB |= set_bit0; 
0402:  BSF    F81.0
....................      delay_us(5); 
0404:  MOVLW  08
0406:  MOVWF  00
0408:  DECFSZ 00,F
040A:  BRA    0408
....................      PORTB &= clear_bit0; 
040C:  BCF    F81.0
.................... //   delay_us(50); 
....................      temp=(dado << 4); 
040E:  SWAPF  23,W
0410:  MOVWF  24
0412:  MOVLW  F0
0414:  ANDWF  24,F
....................      PORTB = temp; 
0416:  MOVFF  24,F81
....................      PORTB |= set_bit0; 
041A:  BSF    F81.0
....................      delay_us(5); 
041C:  MOVLW  08
041E:  MOVWF  00
0420:  DECFSZ 00,F
0422:  BRA    0420
....................      PORTB &= clear_bit0; 
0424:  BCF    F81.0
....................      delay_us(50); 
0426:  MOVLW  53
0428:  MOVWF  00
042A:  DECFSZ 00,F
042C:  BRA    042A
....................     } 
....................  
.................... } 
042E:  RETLW  00
....................  
.................... #separate 
.................... void mostra(char dado) 
.................... { 
....................  display(1,dado); 
*
075E:  MOVLW  01
0760:  MOVWF  22
0762:  MOVFF  21,23
0766:  RCALL  03B4
.................... } 
0768:  RETLW  00
....................  
.................... #include "ds1307.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                               DS1307.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RTC_SDA  PIN_C4  
.................... #define RTC_SCL  PIN_C3  
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL)  
*
0052:  MOVLW  08
0054:  MOVWF  01
0056:  MOVLW  05
0058:  MOVWF  00
005A:  DECFSZ 00,F
005C:  BRA    005A
005E:  BCF    F8B.3
0060:  BCF    F94.3
0062:  MOVLW  06
0064:  MOVWF  00
0066:  DECFSZ 00,F
0068:  BRA    0066
006A:  RLCF   1B,F
006C:  BCF    F8B.4
006E:  BTFSC  FD8.0
0070:  BSF    F94.4
0072:  BTFSS  FD8.0
0074:  BCF    F94.4
0076:  BSF    F94.3
0078:  BTFSS  F82.3
007A:  BRA    0078
007C:  DECFSZ 01,F
007E:  BRA    0056
0080:  MOVLW  05
0082:  MOVWF  00
0084:  DECFSZ 00,F
0086:  BRA    0084
0088:  BCF    F8B.3
008A:  BCF    F94.3
008C:  NOP   
008E:  BSF    F94.4
0090:  MOVLW  06
0092:  MOVWF  00
0094:  DECFSZ 00,F
0096:  BRA    0094
0098:  MOVLW  06
009A:  MOVWF  00
009C:  DECFSZ 00,F
009E:  BRA    009C
00A0:  BSF    F94.3
00A2:  BTFSS  F82.3
00A4:  BRA    00A2
00A6:  CLRF   01
00A8:  MOVLW  06
00AA:  MOVWF  00
00AC:  DECFSZ 00,F
00AE:  BRA    00AC
00B0:  BTFSC  F82.4
00B2:  BSF    01.0
00B4:  BCF    F8B.3
00B6:  BCF    F94.3
00B8:  BCF    F8B.4
00BA:  BCF    F94.4
00BC:  RETLW  00
00BE:  MOVLW  08
00C0:  MOVWF  17
00C2:  MOVFF  00,18
00C6:  BSF    F94.4
00C8:  MOVLW  06
00CA:  MOVWF  00
00CC:  DECFSZ 00,F
00CE:  BRA    00CC
00D0:  BSF    F94.3
00D2:  BTFSS  F82.3
00D4:  BRA    00D2
00D6:  BTFSC  F82.4
00D8:  BSF    FD8.0
00DA:  BTFSS  F82.4
00DC:  BCF    FD8.0
00DE:  RLCF   01,F
00E0:  MOVLW  05
00E2:  MOVWF  00
00E4:  DECFSZ 00,F
00E6:  BRA    00E4
00E8:  BCF    F94.3
00EA:  BCF    F8B.3
00EC:  DECFSZ 17,F
00EE:  BRA    00C6
00F0:  BSF    F94.4
00F2:  MOVLW  06
00F4:  MOVWF  00
00F6:  DECFSZ 00,F
00F8:  BRA    00F6
00FA:  BCF    F8B.4
00FC:  MOVF   18,W
00FE:  BTFSS  FD8.2
0100:  BCF    F94.4
0102:  NOP   
0104:  BSF    F94.3
0106:  BTFSS  F82.3
0108:  BRA    0106
010A:  MOVLW  05
010C:  MOVWF  00
010E:  DECFSZ 00,F
0110:  BRA    010E
0112:  BCF    F8B.3
0114:  BCF    F94.3
0116:  MOVLW  06
0118:  MOVWF  00
011A:  DECFSZ 00,F
011C:  BRA    011A
011E:  BCF    F8B.4
0120:  BCF    F94.4
0122:  RETLW  00
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);  
....................  
.................... void ds1307_init(void)  
.................... {  
....................    BYTE seconds = 0;  
*
016E:  CLRF   13
....................  
....................    i2c_start();  
0170:  BSF    F94.4
0172:  MOVLW  05
0174:  MOVWF  00
0176:  DECFSZ 00,F
0178:  BRA    0176
017A:  BSF    F94.3
017C:  MOVLW  06
017E:  MOVWF  00
0180:  DECFSZ 00,F
0182:  BRA    0180
0184:  BCF    F8B.4
0186:  BCF    F94.4
0188:  MOVLW  05
018A:  MOVWF  00
018C:  DECFSZ 00,F
018E:  BRA    018C
0190:  BCF    F8B.3
0192:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
0194:  MOVLW  D0
0196:  MOVWF  1B
0198:  RCALL  0052
....................    i2c_write(0x00);      // REG 0  
019A:  CLRF   1B
019C:  RCALL  0052
....................    i2c_start();  
019E:  BSF    F94.4
01A0:  MOVLW  05
01A2:  MOVWF  00
01A4:  DECFSZ 00,F
01A6:  BRA    01A4
01A8:  BSF    F94.3
01AA:  MOVLW  06
01AC:  MOVWF  00
01AE:  DECFSZ 00,F
01B0:  BRA    01AE
01B2:  BTFSS  F82.3
01B4:  BRA    01B2
01B6:  BCF    F8B.4
01B8:  BCF    F94.4
01BA:  MOVLW  05
01BC:  MOVWF  00
01BE:  DECFSZ 00,F
01C0:  BRA    01BE
01C2:  BCF    F8B.3
01C4:  BCF    F94.3
....................    i2c_write(0xD1);      // RD from RTC  
01C6:  MOVLW  D1
01C8:  MOVWF  1B
01CA:  RCALL  0052
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
01CC:  CLRF   00
01CE:  RCALL  00BE
01D0:  MOVFF  01,14
01D4:  MOVFF  01,18
01D8:  RCALL  0124
01DA:  MOVFF  01,13
....................    i2c_stop();  
01DE:  BCF    F94.4
01E0:  NOP   
01E2:  BSF    F94.3
01E4:  BTFSS  F82.3
01E6:  BRA    01E4
01E8:  MOVLW  05
01EA:  MOVWF  00
01EC:  DECFSZ 00,F
01EE:  BRA    01EC
01F0:  BRA    01F2
01F2:  NOP   
01F4:  BSF    F94.4
01F6:  MOVLW  05
01F8:  MOVWF  00
01FA:  DECFSZ 00,F
01FC:  BRA    01FA
....................    seconds &= 0x7F;  
01FE:  BCF    13.7
....................  
....................    delay_us(3);  
0200:  MOVLW  04
0202:  MOVWF  00
0204:  DECFSZ 00,F
0206:  BRA    0204
0208:  BRA    020A
....................  
....................    i2c_start();  
020A:  BSF    F94.4
020C:  MOVLW  05
020E:  MOVWF  00
0210:  DECFSZ 00,F
0212:  BRA    0210
0214:  BSF    F94.3
0216:  MOVLW  06
0218:  MOVWF  00
021A:  DECFSZ 00,F
021C:  BRA    021A
021E:  BCF    F8B.4
0220:  BCF    F94.4
0222:  MOVLW  05
0224:  MOVWF  00
0226:  DECFSZ 00,F
0228:  BRA    0226
022A:  BCF    F8B.3
022C:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
022E:  MOVLW  D0
0230:  MOVWF  1B
0232:  RCALL  0052
....................    i2c_write(0x00);      // REG 0  
0234:  CLRF   1B
0236:  RCALL  0052
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
0238:  MOVFF  13,1A
023C:  RCALL  014A
023E:  MOVFF  01,14
0242:  MOVFF  01,1B
0246:  RCALL  0052
....................    i2c_start();  
0248:  BSF    F94.4
024A:  MOVLW  05
024C:  MOVWF  00
024E:  DECFSZ 00,F
0250:  BRA    024E
0252:  BSF    F94.3
0254:  MOVLW  06
0256:  MOVWF  00
0258:  DECFSZ 00,F
025A:  BRA    0258
025C:  BTFSS  F82.3
025E:  BRA    025C
0260:  BCF    F8B.4
0262:  BCF    F94.4
0264:  MOVLW  05
0266:  MOVWF  00
0268:  DECFSZ 00,F
026A:  BRA    0268
026C:  BCF    F8B.3
026E:  BCF    F94.3
....................    i2c_write(0xD0);      // WR to RTC  
0270:  MOVLW  D0
0272:  MOVWF  1B
0274:  RCALL  0052
....................    i2c_write(0x07);      // Control Register  
0276:  MOVLW  07
0278:  MOVWF  1B
027A:  RCALL  0052
....................    i2c_write(0x80);     // Disable squarewave output pin  
027C:  MOVLW  80
027E:  MOVWF  1B
0280:  RCALL  0052
....................    i2c_stop();  
0282:  BCF    F94.4
0284:  NOP   
0286:  BSF    F94.3
0288:  BTFSS  F82.3
028A:  BRA    0288
028C:  MOVLW  05
028E:  MOVWF  00
0290:  DECFSZ 00,F
0292:  BRA    0290
0294:  BRA    0296
0296:  NOP   
0298:  BSF    F94.4
029A:  MOVLW  05
029C:  MOVWF  00
029E:  DECFSZ 00,F
02A0:  BRA    029E
....................  
.................... }  
02A2:  GOTO   0B4A (RETURN)
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... {  
....................   sec &= 0x7F;  
02A6:  BCF    19.7
....................   hr &= 0x3F;  
02A8:  MOVLW  3F
02AA:  ANDWF  17,F
....................  
....................   i2c_start();  
02AC:  BSF    F94.4
02AE:  MOVLW  05
02B0:  MOVWF  00
02B2:  DECFSZ 00,F
02B4:  BRA    02B2
02B6:  BSF    F94.3
02B8:  MOVLW  06
02BA:  MOVWF  00
02BC:  DECFSZ 00,F
02BE:  BRA    02BC
02C0:  BCF    F8B.4
02C2:  BCF    F94.4
02C4:  MOVLW  05
02C6:  MOVWF  00
02C8:  DECFSZ 00,F
02CA:  BRA    02C8
02CC:  BCF    F8B.3
02CE:  BCF    F94.3
....................   i2c_write(0xD0);            // I2C write address  
02D0:  MOVLW  D0
02D2:  MOVWF  1B
02D4:  RCALL  0052
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
02D6:  CLRF   1B
02D8:  RCALL  0052
....................   i2c_write(bin2bcd(sec));      // REG 0  
02DA:  MOVFF  19,1A
02DE:  RCALL  014A
02E0:  MOVFF  01,1A
02E4:  MOVFF  01,1B
02E8:  RCALL  0052
....................   i2c_write(bin2bcd(min));      // REG 1  
02EA:  MOVFF  18,1A
02EE:  RCALL  014A
02F0:  MOVFF  01,1A
02F4:  MOVFF  01,1B
02F8:  RCALL  0052
....................   i2c_write(bin2bcd(hr));      // REG 2  
02FA:  MOVFF  17,1A
02FE:  RCALL  014A
0300:  MOVFF  01,1A
0304:  MOVFF  01,1B
0308:  RCALL  0052
....................   i2c_write(bin2bcd(dow));      // REG 3  
030A:  MOVFF  16,1A
030E:  RCALL  014A
0310:  MOVFF  01,1A
0314:  MOVFF  01,1B
0318:  RCALL  0052
....................   i2c_write(bin2bcd(day));      // REG 4  
031A:  MOVFF  13,1A
031E:  RCALL  014A
0320:  MOVFF  01,1A
0324:  MOVFF  01,1B
0328:  RCALL  0052
....................   i2c_write(bin2bcd(mth));      // REG 5  
032A:  MOVFF  14,1A
032E:  RCALL  014A
0330:  MOVFF  01,1A
0334:  MOVFF  01,1B
0338:  RCALL  0052
....................   i2c_write(bin2bcd(year));      // REG 6  
033A:  MOVFF  15,1A
033E:  RCALL  014A
0340:  MOVFF  01,1A
0344:  MOVFF  01,1B
0348:  RCALL  0052
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
034A:  MOVLW  80
034C:  MOVWF  1B
034E:  RCALL  0052
....................   i2c_stop();  
0350:  BCF    F94.4
0352:  NOP   
0354:  BSF    F94.3
0356:  BTFSS  F82.3
0358:  BRA    0356
035A:  MOVLW  05
035C:  MOVWF  00
035E:  DECFSZ 00,F
0360:  BRA    035E
0362:  BRA    0364
0364:  NOP   
0366:  BSF    F94.4
0368:  MOVLW  05
036A:  MOVWF  00
036C:  DECFSZ 00,F
036E:  BRA    036C
.................... }  
0370:  GOTO   0B6A (RETURN)
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow)  
.................... {  
....................   i2c_start();  
....................   i2c_write(0xD0);  
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
....................   i2c_start();  
....................   i2c_write(0xD1);  
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
....................   year = bcd2bin(i2c_read(0));            // REG 6  
....................   i2c_stop();  
.................... }  
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   i2c_start();  
*
0C78:  BSF    F94.4
0C7A:  MOVLW  05
0C7C:  MOVWF  00
0C7E:  DECFSZ 00,F
0C80:  BRA    0C7E
0C82:  BSF    F94.3
0C84:  MOVLW  06
0C86:  MOVWF  00
0C88:  DECFSZ 00,F
0C8A:  BRA    0C88
0C8C:  BCF    F8B.4
0C8E:  BCF    F94.4
0C90:  MOVLW  05
0C92:  MOVWF  00
0C94:  DECFSZ 00,F
0C96:  BRA    0C94
0C98:  BCF    F8B.3
0C9A:  BCF    F94.3
....................   i2c_write(0xD0);  
0C9C:  MOVLW  D0
0C9E:  MOVWF  1B
0CA0:  CALL   0052
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
0CA4:  CLRF   1B
0CA6:  CALL   0052
....................   i2c_start();  
0CAA:  BSF    F94.4
0CAC:  MOVLW  05
0CAE:  MOVWF  00
0CB0:  DECFSZ 00,F
0CB2:  BRA    0CB0
0CB4:  BSF    F94.3
0CB6:  MOVLW  06
0CB8:  MOVWF  00
0CBA:  DECFSZ 00,F
0CBC:  BRA    0CBA
0CBE:  BTFSS  F82.3
0CC0:  BRA    0CBE
0CC2:  BCF    F8B.4
0CC4:  BCF    F94.4
0CC6:  MOVLW  05
0CC8:  MOVWF  00
0CCA:  DECFSZ 00,F
0CCC:  BRA    0CCA
0CCE:  BCF    F8B.3
0CD0:  BCF    F94.3
....................   i2c_write(0xD1);  
0CD2:  MOVLW  D1
0CD4:  MOVWF  1B
0CD6:  CALL   0052
....................   sec = bcd2bin(i2c_read() & 0x7f);  
0CDA:  MOVLW  01
0CDC:  MOVWF  00
0CDE:  CALL   00BE
0CE2:  MOVF   01,W
0CE4:  ANDLW  7F
0CE6:  MOVWF  14
0CE8:  MOVWF  18
0CEA:  CALL   0124
0CEE:  MOVFF  01,0C
....................   min = bcd2bin(i2c_read() & 0x7f);  
0CF2:  MOVLW  01
0CF4:  MOVWF  00
0CF6:  CALL   00BE
0CFA:  MOVF   01,W
0CFC:  ANDLW  7F
0CFE:  MOVWF  14
0D00:  MOVWF  18
0D02:  CALL   0124
0D06:  MOVFF  01,0D
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
0D0A:  CLRF   00
0D0C:  CALL   00BE
0D10:  MOVF   01,W
0D12:  ANDLW  3F
0D14:  MOVWF  14
0D16:  MOVWF  18
0D18:  CALL   0124
0D1C:  MOVFF  01,0E
....................   i2c_stop();  
0D20:  BCF    F94.4
0D22:  NOP   
0D24:  BSF    F94.3
0D26:  BTFSS  F82.3
0D28:  BRA    0D26
0D2A:  MOVLW  05
0D2C:  MOVWF  00
0D2E:  DECFSZ 00,F
0D30:  BRA    0D2E
0D32:  BRA    0D34
0D34:  NOP   
0D36:  BSF    F94.4
0D38:  MOVLW  05
0D3A:  MOVWF  00
0D3C:  DECFSZ 00,F
0D3E:  BRA    0D3C
....................  
.................... }  
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................   BYTE temp;  
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
014A:  MOVFF  1A,1B
....................   retval = 0;  
014E:  CLRF   1C
....................  
....................   while(1)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
0150:  MOVF   1B,W
0152:  SUBLW  09
0154:  BC    0160
....................     {  
....................       temp -= 10;  
0156:  MOVLW  0A
0158:  SUBWF  1B,F
....................       retval += 0x10;  
015A:  MOVLW  10
015C:  ADDWF  1C,F
....................     }  
....................     else // Get the ones digit by adding the remainder.  
015E:  BRA    0166
....................     {  
....................       retval += temp;  
0160:  MOVF   1B,W
0162:  ADDWF  1C,F
....................       break;  
0164:  BRA    0168
....................     }  
....................   }  
0166:  BRA    0150
....................  
....................   return(retval);  
0168:  MOVFF  1C,01
.................... }  
016C:  RETLW  00
....................  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp;  
....................  
....................   temp = bcd_value;  
*
0124:  MOVFF  18,19
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
0128:  BCF    FD8.0
012A:  RRCF   19,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
012C:  MOVLW  78
012E:  ANDWF  19,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f));  
0130:  RRCF   19,W
0132:  MOVWF  00
0134:  RRCF   00,F
0136:  MOVLW  3F
0138:  ANDWF  00,F
013A:  MOVF   00,W
013C:  ADDWF  19,W
013E:  MOVWF  1A
0140:  MOVF   18,W
0142:  ANDLW  0F
0144:  ADDWF  1A,W
0146:  MOVWF  01
.................... }  
0148:  RETLW  00
....................  
.................... //------------------------------------------------------------------------ 
.................... // Read one byte at the specified address. 
.................... // This function is used to access the control byte 
.................... // or the NVRAM bytes. 
....................  
.................... char ds1307_read_byte(char addr) 
.................... { 
.................... char retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
09A4:  BCF    FF2.6
09A6:  BCF    FF2.7
09A8:  BTFSC  FF2.7
09AA:  BRA    09A6
.................... i2c_start(); 
09AC:  BSF    F94.4
09AE:  MOVLW  05
09B0:  MOVWF  00
09B2:  DECFSZ 00,F
09B4:  BRA    09B2
09B6:  BSF    F94.3
09B8:  MOVLW  06
09BA:  MOVWF  00
09BC:  DECFSZ 00,F
09BE:  BRA    09BC
09C0:  BCF    F8B.4
09C2:  BCF    F94.4
09C4:  MOVLW  05
09C6:  MOVWF  00
09C8:  DECFSZ 00,F
09CA:  BRA    09C8
09CC:  BCF    F8B.3
09CE:  BCF    F94.3
.................... i2c_write(0xD0); 
09D0:  MOVLW  D0
09D2:  MOVWF  1B
09D4:  CALL   0052
.................... i2c_write(addr); 
09D8:  MOVFF  13,1B
09DC:  CALL   0052
....................  
.................... i2c_start(); 
09E0:  BSF    F94.4
09E2:  MOVLW  05
09E4:  MOVWF  00
09E6:  DECFSZ 00,F
09E8:  BRA    09E6
09EA:  BSF    F94.3
09EC:  MOVLW  06
09EE:  MOVWF  00
09F0:  DECFSZ 00,F
09F2:  BRA    09F0
09F4:  BTFSS  F82.3
09F6:  BRA    09F4
09F8:  BCF    F8B.4
09FA:  BCF    F94.4
09FC:  MOVLW  05
09FE:  MOVWF  00
0A00:  DECFSZ 00,F
0A02:  BRA    0A00
0A04:  BCF    F8B.3
0A06:  BCF    F94.3
.................... i2c_write(0xD1); 
0A08:  MOVLW  D1
0A0A:  MOVWF  1B
0A0C:  CALL   0052
.................... retval = i2c_read(0);   // Don't ACK the last byte read 
0A10:  CLRF   00
0A12:  CALL   00BE
0A16:  MOVFF  01,14
.................... i2c_stop(); 
0A1A:  BCF    F94.4
0A1C:  NOP   
0A1E:  BSF    F94.3
0A20:  BTFSS  F82.3
0A22:  BRA    0A20
0A24:  MOVLW  05
0A26:  MOVWF  00
0A28:  DECFSZ 00,F
0A2A:  BRA    0A28
0A2C:  BRA    0A2E
0A2E:  NOP   
0A30:  BSF    F94.4
0A32:  MOVLW  05
0A34:  MOVWF  00
0A36:  DECFSZ 00,F
0A38:  BRA    0A36
.................... enable_interrupts(GLOBAL); 
0A3A:  MOVLW  C0
0A3C:  IORWF  FF2,F
....................  
.................... return(retval); 
0A3E:  MOVFF  14,01
.................... } 
0A42:  GOTO   0D44 (RETURN)
....................  
....................  
....................   
.................... main() 
.................... {  
*
0B36:  CLRF   FF8
0B38:  BCF    FD0.7
0B3A:  CLRF   FEA
0B3C:  CLRF   FE9
0B3E:  BSF    FC1.0
0B40:  BSF    FC1.1
0B42:  BSF    FC1.2
0B44:  BCF    FC1.3
....................     
....................    long int temp; 
....................    float temperatura; 
....................  
....................   BYTE sec;  
....................   BYTE min;  
....................   BYTE hrs;  
....................   BYTE day;  
....................   BYTE month;  
....................   BYTE yr;  
....................   BYTE dow;  
....................    
....................   ds1307_init();  
0B46:  GOTO   016E
....................    
....................   // Set date for -> 15 June 2005 Tuesday  
....................   // Set time for -> 15:20:55  
....................   ds1307_set_date_time(18,11,12,2,22,05,55);  
0B4A:  MOVLW  12
0B4C:  MOVWF  13
0B4E:  MOVLW  0B
0B50:  MOVWF  14
0B52:  MOVLW  0C
0B54:  MOVWF  15
0B56:  MOVLW  02
0B58:  MOVWF  16
0B5A:  MOVLW  16
0B5C:  MOVWF  17
0B5E:  MOVLW  05
0B60:  MOVWF  18
0B62:  MOVLW  37
0B64:  MOVWF  19
0B66:  GOTO   02A6
....................  
....................  
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0B6A:  BCF    FC1.6
0B6C:  BSF    FC2.6
0B6E:  BSF    FC2.7
0B70:  BSF    FC1.7
0B72:  BSF    FC2.0
....................    //enables the a/d module  
....................    set_adc_channel(0); 
0B74:  MOVLW  00
0B76:  MOVWF  01
0B78:  MOVF   FC2,W
0B7A:  ANDLW  C7
0B7C:  IORWF  01,W
0B7E:  MOVWF  FC2
....................    //the next read_adc call will read channel 0 
....................    delay_us(10); 
0B80:  MOVLW  10
0B82:  MOVWF  00
0B84:  DECFSZ 00,F
0B86:  BRA    0B84
0B88:  NOP   
....................    //a small delay is required after setting the channel 
....................  
....................    //aguarda 500ms 
....................    delay_ms(500); 
0B8A:  MOVLW  02
0B8C:  MOVWF  13
0B8E:  MOVLW  FA
0B90:  MOVWF  14
0B92:  CALL   0374
0B96:  DECFSZ 13,F
0B98:  BRA    0B8E
....................     
....................    //inicializa o display LCD 
....................    inic_display(); 
0B9A:  BRA    0430
....................  
....................  
....................    while (true) 
....................    { 
....................  
....................       //starts the conversion and reads the result 
....................       temp = read_adc(); 
0B9C:  BSF    FC2.2
0B9E:  BTFSC  FC2.2
0BA0:  BRA    0B9E
0BA2:  MOVFF  FC3,06
0BA6:  MOVFF  FC4,07
....................  
....................       //faz o calculo para converter a tensao em graus celsius 
....................       temperatura = ((temp - 50) * 8.9)/ 100; 
0BAA:  MOVLW  32
0BAC:  SUBWF  06,W
0BAE:  MOVWF  13
0BB0:  MOVLW  00
0BB2:  SUBWFB 07,W
0BB4:  MOVWF  14
0BB6:  MOVWF  16
0BB8:  MOVFF  13,15
0BBC:  BRA    04D8
0BBE:  MOVFF  03,24
0BC2:  MOVFF  02,23
0BC6:  MOVFF  01,22
0BCA:  MOVFF  00,21
0BCE:  MOVLW  66
0BD0:  MOVWF  28
0BD2:  MOVWF  27
0BD4:  MOVLW  0E
0BD6:  MOVWF  26
0BD8:  MOVLW  82
0BDA:  MOVWF  25
0BDC:  RCALL  0510
0BDE:  MOVFF  00,15
0BE2:  MOVFF  01,16
0BE6:  MOVFF  02,17
0BEA:  MOVFF  03,18
0BEE:  MOVFF  03,1C
0BF2:  MOVFF  02,1B
0BF6:  MOVFF  01,1A
0BFA:  MOVFF  00,19
0BFE:  CLRF   20
0C00:  CLRF   1F
0C02:  MOVLW  48
0C04:  MOVWF  1E
0C06:  MOVLW  85
0C08:  MOVWF  1D
0C0A:  BRA    0602
0C0C:  MOVFF  03,0B
0C10:  MOVFF  02,0A
0C14:  MOVFF  01,09
0C18:  MOVFF  00,08
....................  
....................       //envia o cursor do LCD para a posicao 0,0 
....................       display(0,0x80); 
0C1C:  CLRF   22
0C1E:  MOVLW  80
0C20:  MOVWF  23
0C22:  CALL   03B4
....................  
....................       //imprime na tela a temperatura 
....................       printf(mostra,"Temperatura: %.1lfC   ",temperatura); 
0C26:  CLRF   13
0C28:  MOVF   13,W
0C2A:  CALL   0004
0C2E:  INCF   13,F
0C30:  MOVWF  00
0C32:  MOVWF  21
0C34:  RCALL  075E
0C36:  MOVLW  0D
0C38:  SUBWF  13,W
0C3A:  BNZ   0C28
0C3C:  MOVLW  89
0C3E:  MOVWF  FE9
0C40:  MOVFF  0B,17
0C44:  MOVFF  0A,16
0C48:  MOVFF  09,15
0C4C:  MOVFF  08,14
0C50:  MOVLW  01
0C52:  MOVWF  18
0C54:  BRA    0824
0C56:  MOVLW  12
0C58:  MOVWF  14
0C5A:  MOVF   14,W
0C5C:  CALL   0004
0C60:  INCF   14,F
0C62:  MOVWF  00
0C64:  MOVWF  21
0C66:  RCALL  075E
0C68:  MOVLW  16
0C6A:  SUBWF  14,W
0C6C:  BNZ   0C5A
....................        
....................       //envia o cursor do LCD para a posicao 1,0 
....................       display(0,0xC0); 
0C6E:  CLRF   22
0C70:  MOVLW  C0
0C72:  MOVWF  23
0C74:  CALL   03B4
....................  
....................       //imprime na tela a temperatura 
....................     //ds1307_get_date(day,month,yr,dow);  
....................     ds1307_get_time(hrs,min,sec);  
....................        
....................       sec = ds1307_read_byte(0); 
*
0D40:  CLRF   13
0D42:  BRA    09A4
0D44:  MOVFF  01,0C
....................       sec = bcd2bin(sec); 
0D48:  MOVFF  0C,18
0D4C:  CALL   0124
0D50:  MOVFF  01,0C
....................        
....................     //printf(mostra,"\f\%02d/\%02d/\%02d\r\n",day,month,yr);  
....................     printf(mostra,"Hora: \%02d:\%02d:\%02d", hrs,min,sec);  
0D54:  CLRF   13
0D56:  MOVF   13,W
0D58:  CALL   002C
0D5C:  INCF   13,F
0D5E:  MOVWF  00
0D60:  MOVWF  21
0D62:  RCALL  075E
0D64:  MOVLW  06
0D66:  SUBWF  13,W
0D68:  BNZ   0D56
0D6A:  MOVFF  0E,14
0D6E:  MOVLW  01
0D70:  MOVWF  15
0D72:  RCALL  0A6E
0D74:  MOVLW  3A
0D76:  MOVWF  21
0D78:  RCALL  075E
0D7A:  MOVFF  0D,14
0D7E:  MOVLW  01
0D80:  MOVWF  15
0D82:  RCALL  0A6E
0D84:  MOVLW  3A
0D86:  MOVWF  21
0D88:  RCALL  075E
0D8A:  MOVFF  0C,14
0D8E:  MOVLW  01
0D90:  MOVWF  15
0D92:  RCALL  0A6E
....................  
....................       //alterna o estado do pino D4 
....................       output_toggle(PIN_D4); 
0D94:  BCF    F95.4
0D96:  BTG    F8C.4
....................  
....................       //aguarda 500ms 
....................       delay_ms (500); 
0D98:  MOVLW  02
0D9A:  MOVWF  13
0D9C:  MOVLW  FA
0D9E:  MOVWF  14
0DA0:  CALL   0374
0DA4:  DECFSZ 13,F
0DA6:  BRA    0D9C
....................    } 
0DA8:  BRA    0B9C
.................... } 
0DAA:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
